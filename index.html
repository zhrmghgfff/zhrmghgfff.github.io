<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/iOS-Runtime%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/28/iOS-Runtime%E6%8E%A2%E7%A9%B6/" itemprop="url">iOS Runtime探究</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-28T23:28:10+08:00">
                2020-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>使用 Objective-C 开发 iOS 应用很多年了，一致打交道的都是UI部分，平时看文章也经常会有 runtime 的字眼跳出来，也知道一些 runtime 的相关内容，例如消息发送、消息转发、消息替换，平时交流中也能说上来个一二，但是总体的印象还是混沌模糊的，一直没有细致的静下心来，去了解 runtime , 了解runtime是怎么运行的，那些功能是怎么实现的。</p>
<blockquote>
<p>那么接下来</p>
</blockquote>
</blockquote>
<h1 id="什么是Runtime"><a href="#什么是Runtime" class="headerlink" title="什么是Runtime"></a>什么是Runtime</h1><p>具体了解还是得看官方文档，<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a>，虽然文档不更新了，但是描述还是可以看看的。</p>
<blockquote>
<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
</blockquote>
<p>硬核翻译一下:-) </p>
<blockquote>
<p>Objective-C语言尽可能地将编译时间和链接时间推迟到运行时。只要有可能，它就会动态地执行操作。这意味着该语言不仅需要一个编译器，还需要一个运行时系统来执行编译后的代码。运行时系统 <strong>runtime</strong> 作为Objective-C语言的一种操作系统;它使Objective-C语言的动态特性生效。</p>
</blockquote>
<p>简单组织一下就是：</p>
<ul>
<li><strong>runtime</strong> 是一个系统，通过这个系统，Objective-C 可以将一些决议，放到运行时来处理，而不是在编译、链接时就定死了。这样在运行时处理决议的特性，就是 Objective-C 的动态特性。</li>
</ul>
<blockquote>
<p>PS:英文水平不好的，可以先google翻译，然后再看原文，发现翻译大部分时候，都是狗屁不通😹</p>
</blockquote>
<p>接下来继续阅读文档，发现有几章介绍Rumtime:</p>
<ul>
<li>Runtime Versions and Platforms : <strong>runtime的版本与平台</strong></li>
<li>Interacting with the Runtime : <strong>与runtime的交互</strong></li>
<li>Messaging : <strong>消息传递</strong></li>
<li>Dynamic Method Resolution : <strong>动态方法解析</strong></li>
<li>Message Forwarding : <strong>消息转发</strong></li>
<li>Type Encodings : <strong>类型编码</strong></li>
<li>Declared Properties : <strong>声明属性</strong></li>
</ul>
<blockquote>
<p>这几章基本介绍了 runtime 相关功能，相当于一个总纲，每当没有头绪的时候都可以回来看看</p>
</blockquote>
<p>在<code>与runtime的交互</code>这章中，发现三个与 runtime 系统交互的途径：</p>
<ul>
<li>through Objective-C source code : <strong>通过 Objective-C 源码</strong></li>
<li>through methods defined in the NSObject class of the Foundation framework : <strong>通过 Foundation 框架中的 NSObject 类中定义的方法</strong></li>
<li>through direct calls to runtime functions : <strong>直接通过 runtime 的方法</strong></li>
</ul>
<p>接下来阅读相关内容发现，<strong>runtime</strong> 其实是一个<strong>动态共享库</strong> （真实名字是libobjc），一般放在<code>/usr/include/objc</code>下，runtime 相关的方法可以参考<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc" target="_blank" rel="noopener">Objective-C Runtime Reference</a>，里面介绍了所有的运行时方法。</p>
<p>那么我们要研究 runtime 如何加载，如何处理，只看介绍，还是有点虚，有一个程序员说：<code>Talk is cheap. Show me the code.</code>，看源码才能真切的知道、了解，它是怎么做的。</p>
<blockquote>
<p>如果去查找源码？</p>
</blockquote>
<h1 id="Runtime-源码"><a href="#Runtime-源码" class="headerlink" title="Runtime 源码"></a>Runtime 源码</h1><p>苹果有专门的源码开源网址：<a href="https://opensource.apple.com/" target="_blank" rel="noopener">opensource</a>,选择一个Mac 系统版本，点进去，发现有好多库，搜索<code>objc</code>，找一个<code>objc</code>，后面的数字是他的版本，然后下载，解压，就拿到 <strong>runtime</strong> 的源码了。</p>
<p>解压后，进入源码文件夹（我下载的是 <strong>objc4-781.2</strong>），打开 <strong>objc.xcodeproj</strong>，就可以开始我们的源码解析之路了。</p>
<h2 id="编译-objc-源码"><a href="#编译-objc-源码" class="headerlink" title="编译 objc 源码"></a>编译 objc 源码</h2><p>为了跟踪代码运行，最好还是编辑下源码，实际调试跟踪方法的运行，更好理解整个 <strong>runtime</strong> 的实现。</p>
<h3 id="编译中遇到的问题"><a href="#编译中遇到的问题" class="headerlink" title="编译中遇到的问题"></a>编译中遇到的问题</h3><h4 id="unable-to-find-SDK-‘macosx-internal‘"><a href="#unable-to-find-SDK-‘macosx-internal‘" class="headerlink" title="unable to find SDK ‘macosx.internal‘"></a>unable to find SDK ‘<strong>macosx.internal</strong>‘</h4><p>需要 macOS 的 SDK，直接在工程里面修改配置，<code>Build Settings</code> -&gt; <code>Base SDK</code> ， 选择当前的系统的Mac OS SDK，我的系统是<code>10.15.4</code>，就选择<code>macOS 10.15</code></p>
<h4 id="‘sys-reason-h‘-file-not-found"><a href="#‘sys-reason-h‘-file-not-found" class="headerlink" title="‘sys/reason.h‘ file not found"></a>‘<strong>sys/reason.h</strong>‘ file not found</h4><p>缺少 <code>sys</code> 相关的头文件，这些头文件其实是 <a href="https://zh.wikipedia.org/wiki/XNU" target="_blank" rel="noopener">苹果系统内核 XNU</a> 的头文件，同样的可以去 <a href="https://opensource.apple.com/" target="_blank" rel="noopener">opensource</a> 上，下载到 <code>xnu</code> (下载与 <strong>objc</strong> 同一目录下 <strong>xnu</strong> 即可)，在工程里面，新建一个文件夹，将缺少的文件复制进去。</p>
<blockquote>
<p>PS：工程下的新建目录，例如新建的目录为 <strong>Commons</strong>，新建 <strong>sys</strong> 目录，放置 <strong>sys</strong> 下的文件，最后添加头文件的搜索路径为 <code>$(SRCROOT)/Commons</code>。其他的文件缺失问题，同理操作。</p>
</blockquote>
<p>可以通过谷歌中输入<code>reason.h site:opensource.apple.com</code> 定向检索，文件在哪个库里面。<br>依次需要下载的库为：<code>xnu</code>，<code>dyld</code>，<code>libplatform</code>，<code>libpthread</code>，<code>libc (825版本)</code></p>
<p>一些文件需要特殊处理：</p>
<ul>
<li><p>dyld_priv.h   去掉 bridgeos(3.0) </p>
<ul>
<li>bridgeOS是watchOS的经过重大修改的变体，可在集成的iBridge设备上运行。</li>
<li>iBridge是Mac的嵌入式处理设备系列。当前有两个主要变体。<ul>
<li>iBridge T1-在2016年带Touch Bar的MacBook Pro中发现。</li>
<li>iBridge T2-在iMac Pro和更高版本中找到。</li>
</ul>
</li>
<li>跟我探究runtime关系不大，直接去掉</li>
</ul>
</li>
<li><p>lock_private.h  去掉 bridgeos(4.0) </p>
</li>
<li><p>CrashReporterClient.h 增加宏定义<br><code>#define LIBC_NO_LIBCRASHREPORTERCLIENT</code></p>
</li>
</ul>
<ul>
<li>pthread_machdep.h<br>  这个头文件是在libc(825版本)中的，825之后的版本，已经没有此文件了，跟 objc对应libc库，版本比825高，会出现一些重复定义的东西，例如一些宏，还有函数，直接注释掉pthread_machdep.h的定义即可。</li>
</ul>
<h4 id="Use-of-undeclared-identifier-‘DYLD-MACOSX-VERSION-10-13’"><a href="#Use-of-undeclared-identifier-‘DYLD-MACOSX-VERSION-10-13’" class="headerlink" title="Use of undeclared identifier ‘DYLD_MACOSX_VERSION_10_13’"></a>Use of undeclared identifier ‘<strong>DYLD_MACOSX_VERSION_10_13</strong>’</h4><p>这是MacOS对应的版本宏，定义一下即可，google查找到的<a href="https://docs.rs/goblin/0.0.13/i686-pc-windows-msvc/goblin/mach/constants/" target="_blank" rel="noopener">版本信息</a></p>
<ul>
<li>dyld_priv.h</li>
</ul>
<blockquote>
<p>宏定义习惯写成16进制<br><code>#define DYLD_MACOSX_VERSION_10_11 0x000A0B00</code><br><code>#define DYLD_MACOSX_VERSION_10_12 0x000A0C00</code><br><code>#define DYLD_MACOSX_VERSION_10_13 0x000A0D00</code><br><code>#define DYLD_MACOSX_VERSION_10_14 0x000A0E00</code></p>
</blockquote>
<h4 id="can’t-open-order-file-libobjc-order"><a href="#can’t-open-order-file-libobjc-order" class="headerlink" title="can’t open order file: libobjc.order"></a>can’t open order file: <strong>libobjc.order</strong></h4><p>修改工程配置，添加<code>libobjc.order</code>的路径，<code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Settings</code>，<code>Order file</code> -&gt; <code>$(SRCROOT)/libobjc.order</code></p>
<h4 id="Library-not-found-for-lCrashReporterClient"><a href="#Library-not-found-for-lCrashReporterClient" class="headerlink" title="Library not found for -lCrashReporterClient"></a>Library not found for <strong>-lCrashReporterClient</strong></h4><p>我们不需要崩溃上报，修改配置去掉<code>-lCrashReporterClient</code>，在 <code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Settings</code> -&gt; <code>Linking</code> -&gt; <code>Other Linker Flags</code>，删除所有的<code>-lCrashReporterClient</code></p>
<h4 id="SDK-“macosx-internal”-cannot-be-located"><a href="#SDK-“macosx-internal”-cannot-be-located" class="headerlink" title="SDK “macosx.internal” cannot be located."></a>SDK “macosx.internal” cannot be located.</h4><p>build脚本出现了问题，在 <code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Phases</code> -&gt; <code>Run Script(markgc)</code>中，修改 <code>macosx.internal</code> 为 <code>macosx</code>。</p>
<h3 id="编译成功。"><a href="#编译成功。" class="headerlink" title="编译成功。"></a>编译成功。</h3><h2 id="新建调试的Target"><a href="#新建调试的Target" class="headerlink" title="新建调试的Target"></a>新建调试的Target</h2><p>选择 <code>macOS</code> -&gt; <code>Application</code> -&gt; <code>Command Line Tool</code>，命名为<code>TestRuntime</code><br>关联 <strong>objc</strong> 库：</p>
<ul>
<li><code>target</code> -&gt; <code>TestRuntime</code> -&gt; <code>Build Phases</code> -&gt; <code>Dependencies</code>，添加依赖 <code>objc</code>。</li>
<li><code>target</code> -&gt; <code>TestRuntime</code> -&gt; <code>Build Phases</code> -&gt; <code>Link Binary With Libraries</code>，添加 <code>libobjc.A.dylib</code></li>
</ul>
<blockquote>
<p>在Xcode 11中，默认的 target 是没有权限进行断点调试的，需要修改配置，<code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Settings</code> -&gt; <code>Enable Hardened Runtime</code> -&gt; <code>NO</code></p>
</blockquote>
<h3 id="启动，断点成功"><a href="#启动，断点成功" class="headerlink" title="启动，断点成功"></a>启动，断点成功</h3><p>这样就可以就行调试了。</p>
<h3 id="直接断点进入-objc-源代码"><a href="#直接断点进入-objc-源代码" class="headerlink" title="直接断点进入 objc 源代码"></a>直接断点进入 objc 源代码</h3><p>直接新建 <code>iOS App</code>，进行代码调试，目前还做不到，有好多错误，后续再进行补充。<code>step by step</code>跟踪代码运行，才能更好的理解代码原理。不能的话，就只能依靠代码经验来理解了，难度上升了一些。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>接下来就开始源码解析了。先从感兴趣的地方开始，第一个选择 <code>objc_msgSend</code>，这是 <code>runtime</code> 的精髓所在。</p>
<blockquote>
<p>源码版本 <code>objc4-781.2</code>，版本不同，具体的实现会有差异，请注意。</p>
</blockquote>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p><code>objc_msgSend</code>，Objective-C 中所有对象的方法调用，都是由它来进行间接调用的。解析<code>objc_msgSend</code>，首先需要找到它的实现。</p>
<h3 id="怎么找到objc-msgSend的实现？"><a href="#怎么找到objc-msgSend的实现？" class="headerlink" title="怎么找到objc_msgSend的实现？"></a>怎么找到objc_msgSend的实现？</h3><p>在调试的Target中，在main函数中，随便新建一个对象，调用它的方法，然后进行断点：<br><img src="/images/%E6%88%AA%E5%B1%8F2020-06-01_%E4%B8%8B%E5%8D%881.55.40.png" alt=""></p>
<p>运行程序，在断点处中断，然后按住<code>ctrl</code>键，按f7（其实就是 <code>debug</code> 下的 <code>Step Into Instruction</code>的快捷键），断点处会一直闪烁，继续按，直到跳转到一个新的页面。<br><img src="/images/%E6%88%AA%E5%B1%8F2020-06-01_%E4%B8%8B%E5%8D%882.06.08.png" alt=""></p>
<ul>
<li>上图 <strong>1</strong> 处，可以看到<code>ENTRY _objc_msgSend</code>，这就是 <code>objc_msgSend</code> 的代码实现，而且还是汇编写。</li>
<li>上图 <strong>2</strong> 处，<code>objc-msg-x86_64.s</code>，表示此汇编文件，是为 <code>x86_64</code> 平台编写的，因为我的调试程序是 <code>macOS Command Line Tool</code>。</li>
</ul>
<blockquote>
<p><code>ENTRY</code> 是汇编实现的入口，同样的还有 <code>STATIC_ENTRY</code>，对应的就是 <code>END_ENTRY</code>。</p>
</blockquote>
<p>那么怎么找到 <code>iOS</code> 使用的源码的呢，其实从命名上就可以，很快找到 <code>iOS</code>（最新的就是<code>arm64</code>） 对应的源码，<code>objc-msg-arm64.s</code>，然后搜索 <code>ENTRY _objc_msgSend</code>，就找到了 <code>_objc_msgSend</code> 的实现，接下来就是源码的分析了。</p>
<h3 id="objc-msgSend-源码分析"><a href="#objc-msgSend-源码分析" class="headerlink" title="_objc_msgSend 源码分析"></a>_objc_msgSend 源码分析</h3><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #0			&#x2F;&#x2F; nil check and tagged pointer check nil检测和被标记的指针检测</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">	b.le	LNilOrTagged		&#x2F;&#x2F;  (MSB tagged pointer looks negative MSB标记的指针看起来像是负的 )</span><br><span class="line">#else</span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line">#endif</span><br><span class="line">	ldr	p13, [x0]		&#x2F;&#x2F; p13 &#x3D; isa 读取 isa</span><br><span class="line">	GetClassFromIsa_p16 p13		&#x2F;&#x2F; p16 &#x3D; class 通过 isa 获取 class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend &#x2F;&#x2F;通过 NORMAL 模式，缓存查找</span><br></pre></td></tr></table></figure>

<ol>
<li>首先进行对象指针的判断，判读是不是空指针</li>
<li>不是空指针，再进行标记指针的检测，（在测试环境下，会对指针进行标记，用于信息调试）。</li>
<li>是空指针，直接走 <code>LReturnZero</code>，就是直接返回（清空段寄存器状态）。</li>
<li>读取isa</li>
<li>通过 isa 获取 class</li>
<li>进行缓存查找 <code>CacheLookup</code>。</li>
</ol>
<h4 id="CacheLookup-缓存查找"><a href="#CacheLookup-缓存查找" class="headerlink" title="CacheLookup 缓存查找"></a>CacheLookup 缓存查找</h4><p>代码搜索<code>CacheLookup</code>，发现是一个宏 <code>.macro CacheLookup</code>，具体实现全是汇编（有兴趣的可以看看，我是看不懂），在宏定义的上面有一段关于 <code>CacheLookup</code>的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * CacheLookup NORMAL|GETIMP|LOOKUP &lt;function&gt;</span><br><span class="line"> * 模式有三种：</span><br><span class="line"> * NORMAL 普通</span><br><span class="line"> * GETIMP 获取实现</span><br><span class="line"> * LOOKUP 查找</span><br><span class="line"> *</span><br><span class="line"> * Locate the implementation for a selector in a class method cache.</span><br><span class="line"> * 在类方法缓存中找到选择器的实现。</span><br><span class="line"> *</span><br><span class="line"> * When this is used in a function that doesn&#39;t hold the runtime lock,</span><br><span class="line"> * this represents the critical section that may access dead memory.</span><br><span class="line"> * If the kernel causes one of these functions to go down the recovery</span><br><span class="line"> * path, we pretend the lookup failed by jumping the JumpMiss branch.</span><br><span class="line"> * 当它用于一个不持有运行时锁的函数时，</span><br><span class="line"> * 这表示可能访问死内存的临界段。</span><br><span class="line"> * 如果内核导致其中一个函数停止恢复路径，</span><br><span class="line"> * 我们通过跳过JumpMiss分支来假装查找失败。</span><br><span class="line"> * </span><br><span class="line"> * Takes: 寄存器代表的参数</span><br><span class="line"> *	 x1 &#x3D; selector</span><br><span class="line"> *	 x16 &#x3D; class to be searched</span><br><span class="line"> *</span><br><span class="line"> * Kills:</span><br><span class="line"> * 	 x9,x10,x11,x12, x17</span><br><span class="line"> *</span><br><span class="line"> * On exit: (found) calls or returns IMP</span><br><span class="line"> *                  with x16 &#x3D; class, x17 &#x3D; IMP</span><br><span class="line"> *          (找到)  寄存器x16 &#x3D; class, x17 &#x3D; IMP</span><br><span class="line"> *</span><br><span class="line"> *          (not found) jumps to LCacheMiss</span><br><span class="line"> *          (未找到) 跳转到 LCacheMiss</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看汇编源码，结合说明，发现缓存查找，会有三种结果，<code>CacheHit</code>缓存命中、<code>CheckMiss</code>未检测到、<code>JumpMiss</code>跳转失败。</li>
</ul>
<h5 id="CacheHit-缓存命中"><a href="#CacheHit-缓存命中" class="headerlink" title="CacheHit 缓存命中"></a>CacheHit 缓存命中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x12 &#x3D; address of cached IMP, x1 &#x3D; SEL, x16 &#x3D; isa</span><br><span class="line">.macro CacheHit</span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	TailCallCachedImp x17, x12, x1, x16	&#x2F;&#x2F; authenticate and call imp 验证并调用imp</span><br><span class="line">.elseif $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	mov	p0, p17</span><br><span class="line">	cbz	p0, 9f			&#x2F;&#x2F; don&#39;t ptrauth a nil imp</span><br><span class="line">	AuthAndResignAsIMP x0, x12, x1, x16	&#x2F;&#x2F; authenticate imp and re-sign as IMP 验证imp并重签为imp</span><br><span class="line">9:	ret				&#x2F;&#x2F; return IMP</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	&#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they</span><br><span class="line">	&#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth.</span><br><span class="line">	AuthAndResignAsIMP x17, x12, x1, x16	&#x2F;&#x2F; authenticate imp and re-sign as IMP 验证imp并重签为imp</span><br><span class="line">	ret				&#x2F;&#x2F; return imp via x17</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<ul>
<li>NORMAL模式下，验证并调用imp，<code>TailCallCachedImp</code>是一个宏。</li>
<li>GETIMP模式下，验证imp并重签为imp，返回imp。</li>
<li>LOOKUP模式下，验证imp并重签为imp，返回imp。</li>
</ul>
<h5 id="CheckMiss-未检测到"><a href="#CheckMiss-未检测到" class="headerlink" title="CheckMiss 未检测到"></a>CheckMiss 未检测到</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">	&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	cbz	p9, LGetImpMiss &#x2F;&#x2F;跳转到LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	cbz	p9, __objc_msgSend_uncached &#x2F;&#x2F;跳转到__objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	cbz	p9, __objc_msgLookup_uncached &#x2F;&#x2F;跳转到__objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>缓存未命中的时候都是直接的跳转：</p>
<ul>
<li>GETIMP模式下，跳转到 <code>LGetImpMiss</code>，就是直接返回了。</li>
<li>NORMAL模式下，跳转到 <code>__objc_msgSend_uncached</code>，通过非缓存的方式，发送消息。</li>
<li>LOOKUP模式下，跳转到 <code>__objc_msgLookup_uncached</code>，通过非缓存的方式，查找imp。</li>
</ul>
<h5 id="JumpMiss跳转失败"><a href="#JumpMiss跳转失败" class="headerlink" title="JumpMiss跳转失败"></a>JumpMiss跳转失败</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.macro JumpMiss</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	b	LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	b	__objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	b	__objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>处理基本跟 <code>CheckMiss</code> 一致</p>
<h4 id="objc-msgSend-uncached-通过非缓存的方式，发送消息"><a href="#objc-msgSend-uncached-通过非缓存的方式，发送消息" class="headerlink" title="__objc_msgSend_uncached 通过非缓存的方式，发送消息"></a>__objc_msgSend_uncached 通过非缓存的方式，发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">&#x2F;&#x2F; Out-of-band p16 is the class to search</span><br><span class="line"></span><br><span class="line">MethodTableLookup &#x2F;&#x2F;方法表查询</span><br><span class="line">TailCallFunctionPointer x17 &#x2F;&#x2F;通过指针调用方法</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p>非缓存的方式，发送消息，先进行 <code>MethodTableLookup</code> 方法表查询。</p>
<h4 id="MethodTableLookup-方法表查询"><a href="#MethodTableLookup-方法表查询" class="headerlink" title="MethodTableLookup 方法表查询"></a>MethodTableLookup 方法表查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; push frame</span><br><span class="line">	SignLR</span><br><span class="line">	stp	fp, lr, [sp, #-16]!</span><br><span class="line">	mov	fp, sp</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save parameter registers: x0..x8, q0..q7</span><br><span class="line">	sub	sp, sp, #(10*8 + 8*16)</span><br><span class="line">	stp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	stp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	stp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	stp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	str	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</span><br><span class="line">	&#x2F;&#x2F; receiver and selector already in x0 and x1</span><br><span class="line">	mov	x2, x16</span><br><span class="line">	mov	x3, #3</span><br><span class="line">	bl	_lookUpImpOrForward &#x2F;&#x2F;查找imp或者消息转发</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; IMP in x0</span><br><span class="line">	mov	x17, x0</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; restore registers and return</span><br><span class="line">	ldp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	ldp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	ldp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	ldp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	ldr	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	mov	sp, fp</span><br><span class="line">	ldp	fp, lr, [sp], #16</span><br><span class="line">	AuthenticateLR</span><br></pre></td></tr></table></figure>

<p>还是汇编宏，看的出来中间调用了一个方法<code>_lookUpImpOrForward</code>，查找imp或者消息转发。</p>
<h4 id="lookUpImpOrForward-查找imp或者消息转"><a href="#lookUpImpOrForward-查找imp或者消息转" class="headerlink" title="_lookUpImpOrForward 查找imp或者消息转"></a>_lookUpImpOrForward 查找imp或者消息转</h4><p>通过全局搜索<code>_lookUpImpOrForward</code>，发现只有调用，没有实现，什么情况？</p>
<blockquote>
<p> 汇编中调用C中的函数，函数名前加下划线“_”,也算是约定俗成，这样做的目的是为了防止符号名冲突，因为在一个程序中往往是包含汇编和C文件的，汇编用于启动部分，C文件用于应用程序，最终通过编译器实现编译，对于编译器来说，汇编和C是一视同仁的，那么就会有个问题，如果在汇编和C文件中使用了同一个名字，这是很可能出现的，毕竟汇编相当于机器码也算是稍微高级的语言，在定义子程序或函数时，也是可以用英文拼写的，而C文件中，更会习惯用英文拼写。<br>所以为了防止类似的符号名 冲突，UNIX下的C语言就规定，C语言的源代码文件中的所有全局变量和函数经过编译后，相应的符号名前面会自动的加上下划线“_”。这样做的好处，就是方便是程序开发人员，不用太小心翼翼的起名，避免了与汇编文件中的符号名的冲突。</p>
</blockquote>
<p>继续全局搜索 <code>lookUpImpOrForward</code>，找到函数实现，<code>objc-runtime-old.mm</code> 中实现的是老的方法，<code>Objective-C 2.0</code> 之后就废弃了，<code>objc-runtime-new.mm</code> 中是 <code>2.0</code>的实现。</p>
<p>先看函数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* The standard IMP lookup.</span><br><span class="line">* 标准imp查找</span><br><span class="line">*</span><br><span class="line">* Without LOOKUP_INITIALIZE: tries to avoid +initialize (but sometimes fails)</span><br><span class="line">* 如果没有 LOOKUP_INITIALIZE（查找初始化）：尝试去避免调用 +initialize 方法 （但是经常会失败，而避免不了）</span><br><span class="line">*</span><br><span class="line">* Without LOOKUP_CACHE: skips optimistic unlocked lookup (but uses cache elsewhere)</span><br><span class="line">* 如果没有 LOOKUP_CACHE （查找缓存）：跳过开放式解锁查找 （但是在其他地方使用缓存）</span><br><span class="line">*</span><br><span class="line">* Most callers should use LOOKUP_INITIALIZE and LOOKUP_CACHE</span><br><span class="line">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span><br><span class="line">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span><br><span class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </span><br><span class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span><br><span class="line">*   If you don&#39;t want forwarding at all, use LOOKUP_NIL.</span><br><span class="line">*</span><br><span class="line">* 大部分调用者应该使用 LOOKUP_INITIALIZE 和 LOOKUP_CACHE 的实例，他们是关于类与子类的实例，或者 被知道是nil。</span><br><span class="line">* 如果类是一个未初始化的元类，比一个非nil的实例更快。</span><br><span class="line">* 可能返回_objc_msgForward_impcache。</span><br><span class="line">* 提供给外部使用的imps,必须被转换成 _objc_msgForward 或者 _objc_msgForward_stret。</span><br><span class="line">* 如果你一点也不希望转发，使用 LOOKUP_NIL（查找空）。</span><br><span class="line">*</span><br><span class="line">**********************************************************************&#x2F;</span><br></pre></td></tr></table></figure>

<p>再看下实际代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line">&#123;</span><br><span class="line">    const IMP forward_imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    Class curClass;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    &#x2F;&#x2F; 乐观缓存查找</span><br><span class="line">    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123; &#x2F;&#x2F; 如果有缓存查找标记，进行缓存查找</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) goto done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; runtimeLock is held during isRealized and isInitialized checking</span><br><span class="line">    &#x2F;&#x2F; to prevent races against concurrent realization.</span><br><span class="line">    &#x2F;&#x2F; 在实现和初始化检查期间持有runtimeLock,是防止并发实现之间的竞争。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; runtimeLock is held during method search to make</span><br><span class="line">    &#x2F;&#x2F; method-lookup + cache-fill atomic with respect to method addition.</span><br><span class="line">    &#x2F;&#x2F; Otherwise, a category could be added but ignored indefinitely because</span><br><span class="line">    &#x2F;&#x2F; the cache was re-filled with the old value after the cache flush on</span><br><span class="line">    &#x2F;&#x2F; behalf of the category.</span><br><span class="line">    &#x2F;&#x2F; 在方法搜索期间保持的 runtimeLock，使 method-lookup + cache-fill保持原子性，相对于方法添加。</span><br><span class="line">    &#x2F;&#x2F; 另外，一个可以添加的类别，应该无限期地忽略它，因为类别的缓存刷新之后，缓存被重新填充为原来的旧值。</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t want people to be able to craft a binary blob that looks like</span><br><span class="line">    &#x2F;&#x2F; a class but really isn&#39;t one and do a CFI attack.</span><br><span class="line">    &#x2F;&#x2F; 我们不希望人们能够创建一个看起来像类但实际上不是类的二进制大对象，并进行CFI攻击。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; To make these harder we want to make sure this is a class that was</span><br><span class="line">    &#x2F;&#x2F; either built into the binary or legitimately registered through</span><br><span class="line">    &#x2F;&#x2F; objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.</span><br><span class="line">    &#x2F;&#x2F; 为了增加难度，我们需要确保这是一个内建在二进制文件中的类，</span><br><span class="line">    &#x2F;&#x2F; 或者是通过objc_duplicateClass、objc_initializeClassPair或objc_allocateClassPair合法注册的类。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; TODO: this check is quite costly during process startup.</span><br><span class="line">    &#x2F;&#x2F; TODO: 这种检查在进程启动期间非常昂贵。</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (slowpath(!cls-&gt;isRealized())) &#123; &#x2F;&#x2F;类是否被实现了</span><br><span class="line">        &#x2F;&#x2F;实现类，也可能是swift的类</span><br><span class="line">        cls &#x3D; realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line">        &#x2F;&#x2F; runtimeLock可能已经被删除，但现在又被锁定了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化类</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, class_initialize will send +initialize and </span><br><span class="line">        &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">        &#x2F;&#x2F; 如果sel &#x3D;&#x3D; initialize, class_initialize将发送+initialize，</span><br><span class="line">        &#x2F;&#x2F; 然后在此过程完成后，messenger将再次发送+initialize。</span><br><span class="line">        &#x2F;&#x2F; 当然，如果这不是从messenger调用的，那么它就不会发生。2778172</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass &#x3D; cls;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The code used to lookup the class&#39;s cache again right after</span><br><span class="line">    &#x2F;&#x2F; we take the lock but for the vast majority of the cases</span><br><span class="line">    &#x2F;&#x2F; evidence shows this is a miss most of the time, hence a time loss.</span><br><span class="line">    &#x2F;&#x2F; 在锁定之后，用于再次查找类缓存的代码，但是对于绝大多数情况，</span><br><span class="line">    &#x2F;&#x2F; 有证据表明这在大多数情况下是错误的，因此是时间损失。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; The only codepath calling into this without having performed some</span><br><span class="line">    &#x2F;&#x2F; kind of cache lookup is class_getInstanceMethod().</span><br><span class="line">    &#x2F;&#x2F; 惟一调用它而没有执行某种缓存查找的代码路径是class_getInstanceMethod()。</span><br><span class="line"></span><br><span class="line">    for (unsigned attempts &#x3D; unreasonableClassCount();;) &#123;&#x2F;&#x2F;一个防止循环自旋的数</span><br><span class="line">        &#x2F;&#x2F; curClass method list.</span><br><span class="line">        &#x2F;&#x2F; 从当前类的方法列表查找。</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123; &#x2F;&#x2F;找到直接返回</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (slowpath((curClass &#x3D; curClass-&gt;superclass) &#x3D;&#x3D; nil)) &#123;</span><br><span class="line">            &#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help.</span><br><span class="line">            &#x2F;&#x2F; Use forwarding.</span><br><span class="line">            &#x2F;&#x2F; 没有找到方法，而且方法解析器没有作用，进行方法转发</span><br><span class="line">            imp &#x3D; forward_imp;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">        &#x2F;&#x2F; 如果超类链中有一个循环，则停止</span><br><span class="line">        if (slowpath(--attempts &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass cache.</span><br><span class="line">        &#x2F;&#x2F; 从父类的缓存查找</span><br><span class="line">        imp &#x3D; cache_getImp(curClass, sel);&#x2F;&#x2F;这是个汇编方法，内部调用CacheLookUp</span><br><span class="line">        if (slowpath(imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">            &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method</span><br><span class="line">            &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fastpath(imp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line">    &#x2F;&#x2F; 没有找到方法，尝试方法解析器</span><br><span class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^&#x3D; LOOKUP_RESOLVER;</span><br><span class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);&#x2F;&#x2F;找到后，标记和放到缓存。</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有 <code>LOOKUP_CACHE</code> 标记，进行缓存查找。</li>
<li>检测是否是已知的类</li>
<li>判断类是否已经实现，如果没实现，实现类（也有肯是swift的类）</li>
<li>如果有 <code>LOOKUP_INITIALIZE</code> 标记，判断是否已经初始化。<ul>
<li>如果没有初始化，进行类初始化，这时，会调用类的 <code>+initialize</code>方法。</li>
</ul>
</li>
<li>进行方法的循环查找。<ul>
<li>从类的方法列表中查找。<ul>
<li>如果找到，跳转到 <code>done</code>。</li>
</ul>
</li>
<li>未找到，<code>curClass</code> 指向 父类。<ul>
<li>如果父类是nil，说明查找失败，进行消息转发，并跳出循环。</li>
</ul>
</li>
<li>从父类的缓存中查找。</li>
<li>如果 方法 == <code>forward_imp</code>， 跳出循环。</li>
<li>如果找到，跳转到 <code>done</code>。</li>
</ul>
</li>
<li>如果有 <code>LOOKUP_RESOLVER</code>, 返回 方法解析。</li>
<li><code>done</code> <ul>
<li>标记方法并放到缓存。</li>
</ul>
</li>
<li><code>done_nolock</code><ul>
<li>如果有 <code>LOOKUP_NIL</code> 标记，并且 方法 == <code>forward_imp</code>，返回 nil。</li>
</ul>
</li>
<li>返回方法imp。</li>
</ul>
<p>上面是整个方法查找流程，先找缓存，再找方法列表，然后去父类的缓存查找，再次是父类的方法列表，知道父类是nil，查找失败，触发消息转发。<br>首次查找的时候，会有 <code>LOOKUP_RESOLVER</code>标记，找不到的时候，会触发 <code>resolveMethod_locked</code>方法解析，整个函数会调用类的 <code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，然后再进行一次方法查找 <code>lookUpImpOrForward</code>，这次就没有 <code>LOOKUP_RESOLVER</code>标记了。</p>
<h4 id="objc-msgForward-方法转发"><a href="#objc-msgForward-方法转发" class="headerlink" title="_objc_msgForward 方法转发"></a>_objc_msgForward 方法转发</h4><ul>
<li>当方法查找失败的时候，触发消息转发 <code>_objc_msgForward_impcache</code>，而 <code>_objc_msgForward_impcache</code> 内部汇编实现，直接调用的 <code>__objc_msgForward</code>。</li>
<li><code>__objc_msgForward</code> 内部实现，调用了 <code>__objc_forward_handler</code>。</li>
</ul>
<h4 id="objc-forward-handler-方法转发句柄"><a href="#objc-forward-handler-方法转发句柄" class="headerlink" title="_objc_forward_handler 方法转发句柄"></a>_objc_forward_handler 方法转发句柄</h4><p>这是一个函数指针，根据宏定义，有不同的实现，研究版本是 <code>Objective-C 2.0</code>，所以是 <code>__OBJC2__</code> 对应的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#if !__OBJC2__</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default forward handler (nil) goes to forward:: dispatch.</span><br><span class="line">void *_objc_forward_handler &#x3D; nil;</span><br><span class="line">void *_objc_forward_stret_handler &#x3D; nil;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default forward handler halts the process.</span><br><span class="line">__attribute__((noreturn, cold)) void</span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler &#x3D; (void*)objc_defaultForwardHandler;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_STRET</span><br><span class="line">struct stret &#123; int i[100]; &#125;;</span><br><span class="line">__attribute__((noreturn, cold)) struct stret</span><br><span class="line">objc_defaultForwardStretHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    objc_defaultForwardHandler(self, sel);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_stret_handler &#x3D; (void*)objc_defaultForwardStretHandler;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><code>void *_objc_forward_handler = (void*)objc_defaultForwardHandler</code>，表示最后的实现是 <code>objc_defaultForwardHandler</code>，在里面我们看到了熟悉的 <code>unrecognized selector sent to instance</code> 未定义的错误打印。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<p>精简步骤为：</p>
<ol>
<li>空指针检测</li>
<li>缓存快速查找</li>
<li>非缓存的慢速查找（方法列表查询）<ol>
<li>检测类实现</li>
<li>检测类初始化</li>
<li>从当前类的方法列表查找，找打跳转到<code>10</code>，未找到跳转<code>4</code></li>
<li>将当前类指向父类，如果父类为空，imp = forward_imp，跳转到<code>7</code>，不为空，跳转<code>5</code></li>
<li>查找父类的缓存，找打跳转到<code>10</code>，未找到跳转<code>6</code></li>
<li>跳转到3</li>
<li>查找结束</li>
<li>检测LOOKUP_RESOLVER，有，跳转到<code>9</code>，没有跳转到<code>10</code></li>
<li>方法解析<ol>
<li>是否元类，是跳转到2，不是跳转到<code>4</code></li>
<li>调用<code>+resolveClassMethod</code></li>
<li>快速缓存查找，找到跳转到<code>5</code>，未找到跳转到<code>4</code></li>
<li>调用<code>+resolveInstanceMethod</code></li>
<li>带有缓存标记的普通查找。</li>
</ol>
</li>
<li>标记并缓存imp</li>
<li>返回imp</li>
</ol>
</li>
<li>imp是普通imp，直接调用。</li>
<li>imp是forward_imp，实际实现是<code>_objc_forward_handler</code>，指向的是<code>objc_defaultForwardHandler</code>，打印消息，并抛出异常。</li>
</ol>
<blockquote>
<p>从上面的步骤看出，当方法未找到时，源码中只触发了，消息转发的第一步，<strong>动态解析</strong>，即<code>+resolveClassMethod</code>、<code>+resolveInstanceMethod</code>，并没有后续的，<strong>快速转发</strong>，以及<strong>普通转发阶段</strong>，大概是在<code>Foundation</code>中做了，<code>_objc_forward_handler</code>是一个函数指针，后续是可以被赋值改变的。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
