<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<link rel="stylesheet" href="/styles/main.css">

    <meta name="generator" content="Hexo 4.2.1"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">M的博客</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
    <div class="posts-wrapper">
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/06/09/Swift-%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/">Swift 一步步解决回调地狱</a>
            </div>
            <p class="sub">Jun 09 2020</p>
            <div class="post-content">
                <h1 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h1><p>回调地狱，是多线程任务中，经常会遇到的问题，任务中经常有这样的需求，任务2要依赖任务1，必须在任务1完成之后再执行，最普通的做法就是 <code>GCD</code> 异步执行，完成后，开始下一个任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    sleep(1)</span><br><span class="line"></span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        &#x2F;&#x2F;任务2</span><br><span class="line">        sleep(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是连续性<code>3</code>个任务，或<code>4</code>个任务，或<code>n</code>个任务，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    sleep(1)</span><br><span class="line"></span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        &#x2F;&#x2F;任务2</span><br><span class="line">        sleep(1)</span><br><span class="line"></span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            &#x2F;&#x2F;任务3</span><br><span class="line">            sleep(1)</span><br><span class="line"></span><br><span class="line">            DispatchQueue.global().async &#123;</span><br><span class="line">                &#x2F;&#x2F;任务4</span><br><span class="line">                sleep(1)</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了熟悉的回调地狱，谁都不希望写这样的代码，可读性太差了。调试起来也是灾难。</p>
<blockquote>
<p>可能有人会说，为什么不使用，串行队列，多方便，但是串行队列，添加完的任务，是没办法取消的，或者取消起来很麻烦，再者，一般这种任务依赖都是数据上的有依赖的，使用串行队列，数据传递也是问题。</p>
</blockquote>
<h1 id="回调地狱的思考"><a href="#回调地狱的思考" class="headerlink" title="回调地狱的思考"></a>回调地狱的思考</h1><p>现实的任务，例如网络任务，都是有自己的回调的，一般都是封装成是一个函数，回调是一个<code>block</code>，作为参数传进去。但是如果任务有顺序依赖，还是会有回调地狱存在。<br>怎么才能改善这种情况呢？</p>
<h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p>链式编程可以把对同一个实例对象同时调用N次方法。代码的可读性更好。 比较有名的第三方库：<code>OC</code> 的 <code>Masonry</code>、<code>Swift</code> 的 <code>SnapKit</code>。</p>
<p><strong>普通的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;未处理代码</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    self.method1()</span><br><span class="line">    self.method2()</span><br><span class="line">    self.method3()</span><br><span class="line">    self.method4()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method1() &#123;</span><br><span class="line">    print(&quot;method1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method2() &#123;</span><br><span class="line">    print(&quot;method2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method3() &#123;</span><br><span class="line">    print(&quot;method3&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method4() &#123;</span><br><span class="line">    print(&quot;method4&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链式代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 链式处理后代码</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    _ &#x3D; self.method1().method2().method3().method4()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method1() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method1&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method2() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method2&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method3() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method3&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method4() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method4&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改的思路"><a href="#修改的思路" class="headerlink" title="修改的思路"></a>修改的思路</h2><p>链式编程的写法，特别适合用来改造，回调地狱，理想的任务依赖，通过链式的调用，非常合适，看起来，就知道后一个任务依赖前一个任务。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; </span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    sleep(1)</span><br><span class="line">&#125;</span><br><span class="line">.task&#123; </span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    sleep(1)</span><br><span class="line">&#125;</span><br><span class="line">.task&#123; </span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    sleep(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务就是<code>block</code>，<code>block</code>有两个优点：</p>
<ul>
<li>可以存储、传递。</li>
<li>可以灵活的实现任务。</li>
</ul>
<blockquote>
<p>按照上面设想，我们来一步一步实现。</p>
</blockquote>
<h1 id="MyGCD-1-0"><a href="#MyGCD-1-0" class="headerlink" title="MyGCD 1.0"></a>MyGCD 1.0</h1><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>链式编程精髓就是<strong>返回对象自己</strong>，后续就可以进行正常调用，依次再次调用函数，就形成了链式调用。<br>那么初始版本的 <code>MyGCD</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    typealias Task &#x3D; () -&gt; Void</span><br><span class="line"></span><br><span class="line">    func task(task: Task) -&gt; MyGCD &#123;</span><br><span class="line">        task()</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的写法，会有警告<code>Result of call to &#39;task(task:)&#39; is unused</code>，就是返回值没有使用，在函数定义的时候加上<code>@discardableResult</code>，让编译器不用提示这个警告。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func task(task: Task) -&gt; MyGCD &#123;</span><br><span class="line">    task()</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    print(&quot;任务1&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    print(&quot;任务2&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    print(&quot;任务3&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">任务1</span><br><span class="line">任务2</span><br><span class="line">任务3</span><br><span class="line">发布任务完毕</span><br></pre></td></tr></table></figure>

<p>链式调用成功，但是任务还没添加异步和耗时呢，现在我们添加一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务1 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务1 结束&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务2 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务2 结束&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务3 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务3 结束&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">任务1 开始</span><br><span class="line">发布任务完毕</span><br><span class="line">任务3 开始</span><br><span class="line">任务2 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 结束</span><br></pre></td></tr></table></figure>

<p>全乱了，异步执行之后，都是子线程执行，开始和结束都是随机的，再次运行一次，结果还会不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">任务2 开始</span><br><span class="line">任务3 开始</span><br><span class="line">任务1 开始</span><br><span class="line">发布任务完毕</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 结束</span><br><span class="line">任务1 结束</span><br></pre></td></tr></table></figure>

<p>怎么办呢？</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>多线程同步的一般会使用信号量 <code>DispatchSemaphore</code>，信号量内部维护一个 <code>value</code>，信号量的核心就在于对 <code>value</code>的增减。</p>
<ul>
<li>init(value: Int) 以一个数初始化信号量</li>
<li>wait() 等待，当信号量的 <code>value</code> 大于等于1时，返回，并 <code>value</code> - 1</li>
<li>signal() 发送信号，信号量的 <code>value</code> + 1</li>
</ul>
<p>现在使用信号量改造一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务1 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务1 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;.task &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务2 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务2 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;.task &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务3 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务3 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">发布任务完毕</span><br></pre></td></tr></table></figure>

<p>任务按顺序执行了，但是<code>发布任务完毕</code>跑到了最后，因为<code>semaphore.wait()</code>会阻塞当前线程，那么怎么不阻塞当前线程呢？<strong>答案是</strong>：使任务所在的<code>block</code>，在子线程异步执行。修改代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修改MyGCD的task方法</span><br><span class="line">@discardableResult</span><br><span class="line">func task(task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        task()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了看到主线程是否被阻塞，在每个任务的异步前增加打印，因为我们的任务结构相似，我们封装一个方法，方便我们调试，并且精简下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func createTask(_ desc: String) &#123;</span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    print(&quot;\(desc) 发布&quot;)</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;\(desc) 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;\(desc) 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的任务代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line">    createTask(&quot;任务1&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    createTask(&quot;任务2&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    createTask(&quot;任务3&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>运行，输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发布任务完毕</span><br><span class="line">任务2 发布</span><br><span class="line">任务1 发布</span><br><span class="line">任务3 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务1 开始</span><br><span class="line">任务3 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务3 结束</span><br><span class="line">任务2 结束</span><br></pre></td></tr></table></figure>

<p>发现没有阻塞当前线程，但是任务又乱了…， 而且任务的发布也是乱的，按照我们的设想，任务的发布也应该是顺序的。</p>
<h2 id="还是信号量"><a href="#还是信号量" class="headerlink" title="还是信号量"></a>还是信号量</h2><p>保证任务的发布，也是需要信号量来控制任务<code>block</code>的执行，修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func task(task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        task()</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">    semaphore.wait()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">发布任务完毕</span><br></pre></td></tr></table></figure>

<p>所有的执行都顺序，执行了，但是老问题又来了，阻塞当前线程了，用信号量将所有的任务串了起来，效果等同于同步执行，但是我们一般都希望，任务是异步执行的，不用阻塞当前线程，那么创建任务的方式需要修改，改成我们正常的任务实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func createTask(_ desc: String, complete:() -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">    print(&quot;\(desc) 发布&quot;)</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;\(desc) 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;\(desc) 结束&quot;)</span><br><span class="line"></span><br><span class="line">        complete()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回归现实"><a href="#回归现实" class="headerlink" title="回归现实"></a>回归现实</h2><p>正常的任务，异步执行，完成之后有一个回调，那么我们的 <code>MyGCD</code> 怎么知道任务回调回来了呢，也就是 <code>任务的完成</code> ？现在的方式，没有地方接受，以及处理<code>任务的完成</code>。那么整理一下<code>MyGCD</code>的功能：</p>
<ol>
<li>将任务传递进去</li>
<li>合适的时机执行任务</li>
<li>任务执行完成之后，通知我们任务执行完成</li>
<li>通知后续的任务执行</li>
</ol>
<p>第<code>1</code>步：参数是 <code>block</code> 即可满足要求。<br>第<code>2</code>步：合适的时机，一般我们创建任务的时候都希望，立即执行。<br>第<code>3</code>步：返回来通知任务完成，那么我们需要将对象传递进任务中，也即是<code>block</code>中，那么<code>block</code> 就需要一个参数 <code>MyGCD</code>。<br>第<code>4</code>步：后续任务，需要单独一个方法来处理，并且只能先存起来，等待当前任务完成后，才能开始任务。</p>
<p>结合上面的几点，其实不需要信号量了，我们需要暴露一个方法，来处理 <code>任务的完成</code>，现在对 <code>MyGCD</code> 进行改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class MyGCD &#123;</span><br><span class="line">    typealias Task &#x3D; (MyGCD) -&gt; Void</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务完成后执行的方法</span><br><span class="line">    fileprivate var complete : Task?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: block 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">    @discardableResult</span><br><span class="line">    func task(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">        startTask(action)</span><br><span class="line"></span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 设置完成的回调</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: block 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">    @discardableResult</span><br><span class="line">    func onComplete(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">        complete &#x3D; action</span><br><span class="line"></span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务完成</span><br><span class="line">    func taskDone() &#123;</span><br><span class="line">        if let complete &#x3D; complete &#123;</span><br><span class="line">            complete(self)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; MARK: 私有函数</span><br><span class="line">    fileprivate func startTask(_ task:@escaping Task) &#123;</span><br><span class="line"></span><br><span class="line">        var gcd:MyGCD? &#x3D; self</span><br><span class="line"></span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line"></span><br><span class="line">            task(gcd!)</span><br><span class="line"></span><br><span class="line">            gcd &#x3D; nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有个小技巧，<code>MyGCD</code> 生成的对象是一个局部对象，在<code>任务发布完成</code>后，生命周期就应该结束了，而<code>任务block</code>中，需要传入这个对象，如果传入的是<code>strong</code>的对象，那么就会形成<code>循环引用</code>，导致 <code>MyGCD</code> 对象无法释放，如果传入的是<code>weak</code>的对象，因为他的生命周期问题，直接就被释放了，导致<code>任务block</code>中，传入的 <code>MyGCD</code> 对象为 <code>nil</code> 。<br>解除循环引用的一个小技巧，在<code>block</code>强引用捕获对象的时候，在适当的时机，将捕获的对象在 <code>block</code> 中释放掉，就可以解除循环引用，简单的操作就是，将变量赋值成 <code>nil</code>，被引用的对象就减少了一个引用，就可以被释放掉了。</p>
</blockquote>
<ul>
<li>新增 <code>onComplete</code> 方法，设置任务完成后的回调，就是下一个任务。</li>
<li>新增 <code>taskDone</code> 方法，任务完成。在任务 <code>block</code> 中，完成任务后，需要调用此方法。</li>
</ul>
<p>最后是运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.taskDone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.onComplete&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.taskDone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.onComplete &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.taskDone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">发布任务完毕</span><br><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>出现了两个问题：</p>
<ul>
<li><code>任务1</code> 之后是 <code>任务3</code>，不是 <code>任务2</code>，顺序不对。</li>
<li><code>任务3</code> 一直循环，不结束。</li>
</ul>
<p>对于顺序问题，因为我们返回的都是同一个 <code>MyGCD</code>对象，所以后调用的 <code>onComplete</code>，会覆盖前一个的调用，因为 <code>onComplete</code> 中传入的下一个任务，所以应该返回一个新的<code>MyGCD</code>对象，那么修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func onComplete(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有个问题，实际的任务 <code>action</code>，是在其他地方调用的，而 <code>newGCD</code> 是个局部变量，拿不到怎么办？<br>其实我们有一个很好的方法来解决他，那就是 <code>block</code>，没错，就是 <code>block</code>, 使用 <code>block</code> 可以捕获变量的特性，来传递对象。那么就可以这样修改，在 <code>MyGCD</code> 中声明一个 <code>block</code> 属性，然后对他进行赋值，来传递 <code>newGCD</code>。</p>
<p>生命一个 <code>completeAction</code> 属性，进行赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func onComplete(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line"></span><br><span class="line">    completeAction &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">        action(newGCD)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务完成后，执行 <code>completeAction</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func taskDone() &#123;</span><br><span class="line">    if let completeAction &#x3D; completeAction &#123;</span><br><span class="line">        completeAction()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发布任务完毕</span><br><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br></pre></td></tr></table></figure>

<p>结果完美。</p>
<p>但是还需要验证一下，创建的临时 <code>MyGCD</code> 对象，有没有被释放，给 <code>MyGCD</code> 添加 <code>init</code> 和 <code>deinit</code> 方法，再增加一个 <code>tag</code> 属性，来区分各个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;记录总创建的个数</span><br><span class="line">fileprivate static var count:Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 标记，区分每个不同的对象</span><br><span class="line">fileprivate var tag: Int</span><br><span class="line"></span><br><span class="line">init() &#123;</span><br><span class="line"></span><br><span class="line">    tag &#x3D; MyGCD.count</span><br><span class="line"></span><br><span class="line">    print(&quot;init : \(tag)&quot;)</span><br><span class="line"></span><br><span class="line">    MyGCD.count +&#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deinit &#123;</span><br><span class="line">    print(&quot;deinit : \(tag)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来运行下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">init : 1</span><br><span class="line">init : 2</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 发布</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 发布</span><br><span class="line">deinit : 1</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">deinit : 2</span><br></pre></td></tr></table></figure>

<p>3个任务，创建了 <code>MyGCD</code> 三个对象，执行完任务后，对象被释放，任务顺序也跟预想的一致，而且 <code>MyGCD</code> 对象的创建以及释放顺序，也跟任务的顺序一致。</p>
<h2 id="1-0-大功告成"><a href="#1-0-大功告成" class="headerlink" title="1.0 大功告成"></a>1.0 大功告成</h2><h1 id="MyGCD-2-0"><a href="#MyGCD-2-0" class="headerlink" title="MyGCD 2.0"></a>MyGCD 2.0</h1><p><code>1.0</code>完成了，证明<code>回调地狱</code>也不是什么难题吗，我们完全可以解决。<br>但是，现实的任务，没有那么简单，任务执行的过程中，会有各种各样的麻烦、状况，或者说异常出现，例如网路任务：</p>
<ul>
<li><p>正常返回</p>
</li>
<li><p>请求超时</p>
</li>
<li><p>请求参数错误</p>
</li>
<li><p>服务器出异常，无法访问</p>
</li>
<li><p>网络异常，无法发起请求</p>
</li>
<li><p>…等等问题</p>
<p><code>1.0</code> 只能处理正常返回的情况，其他的异常情况，不能处理，而现实中的任务依赖，一旦任务出现异常，那么后续的任务就没有继续执行的意思了，而且异常发生了，我们需要对异常进行处理，那么就需要对我们的<code>MyGCD</code>，进行再次的修改。</p>
</li>
</ul>
<h2 id="增加next"><a href="#增加next" class="headerlink" title="增加next"></a>增加<code>next</code></h2><p>之前的<code>onComplete</code>有个问题，那就是命名，其实应该是下一个任务，并且使用方式也不对，应该将 <code>block</code> 任务放到 <code>newGCD</code> 中，所以现在将方法名字修改掉，改为 <code>next</code>，那么对应 <code>complete</code>属性，也就不需要了，我们需要的是一个新的成员变量，来保存<code>newGCD</code>，并且还需要一个属性，来保存下一个 <code>block</code> 任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 下一个 MyGCD</span><br><span class="line">fileprivate var nextGCD : MyGCD?</span><br><span class="line">&#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">fileprivate var task : Task?</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 下一个任务</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Parameter action: block 任务</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">@discardableResult</span><br><span class="line">func next(_ task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line">    newGCD.task &#x3D; task</span><br><span class="line">    nextGCD &#x3D; newGCD</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加-State"><a href="#增加-State" class="headerlink" title="增加 State"></a>增加 <code>State</code></h2><p>现在任务结束需要一些状态，<code>完成</code>、<code>错误</code>以及<code>取消</code>，当任务链中的有错误发生时，后续的任务就需要取消了，需要定义一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 任务结束时的状态</span><br><span class="line">enum State &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    case complete(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    case error(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取消</span><br><span class="line">    case cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于返回的结果，暂时定义 <code>code</code>、<code>message</code>、<code>data</code> 三个属性，如果有需要，可以再自定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 结果</span><br><span class="line">struct Result &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 状态码</span><br><span class="line">    var code: Int</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 信息</span><br><span class="line">    var message: String</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 数据</span><br><span class="line">    var data: Any?</span><br><span class="line"></span><br><span class="line">    init(_ code: Int,_ message: String &#x3D; &quot;&quot;,_ data: Any? &#x3D; nil) &#123;</span><br><span class="line">        self.code &#x3D; code</span><br><span class="line">        self.message &#x3D; message</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加-error"><a href="#增加-error" class="headerlink" title="增加 error"></a>增加 <code>error</code></h2><p>现在状态有了，那么就需要增加对错误的处理了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typealias ResultAction &#x3D; (Result) -&gt; Void</span><br><span class="line">&#x2F;&#x2F;&#x2F; 错误处理</span><br><span class="line">fileprivate var error : ResultAction?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 错误处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Parameter action: block 处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">@discardableResult</span><br><span class="line">func error(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    error &#x3D; action</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加complete"><a href="#增加complete" class="headerlink" title="增加complete"></a>增加<code>complete</code></h2><p>既然有任务的错误，那么对应的就有任务的完成处理，而<code>next</code>专职于下一个任务，增加<code>complete</code>处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 完成处理</span><br><span class="line">fileprivate var complete : ResultAction?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 完成处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Parameter action: block 处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">@discardableResult</span><br><span class="line">func complete(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改endAction"><a href="#修改endAction" class="headerlink" title="修改endAction"></a>修改<code>endAction</code></h2><p>原来的 <code>completeAction</code> 只是简单的执行下 <code>complete</code>，现在需要处理结束后不同的状态，名字改为 <code>endAction</code> 更为合适一些，而且，只有当 <code>next</code>、<code>complete</code> 或者 <code>error</code> 处理添加的时候，才需要添加，其他情况并不需要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typealias EndAction &#x3D; (State) -&gt; Void</span><br><span class="line">&#x2F;&#x2F;&#x2F; 任务结束处理</span><br><span class="line">fileprivate var endAction : EndAction?</span><br><span class="line">&#x2F;&#x2F;&#x2F; 任务完成</span><br><span class="line">func end(_ state: State) &#123;</span><br><span class="line">    if let endAction &#x3D; endAction &#123;</span><br><span class="line">        endAction(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 创建endAction</span><br><span class="line">fileprivate func createEndAction() &#123;</span><br><span class="line"></span><br><span class="line">    if endAction !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var gcd:MyGCD? &#x3D; self</span><br><span class="line"></span><br><span class="line">    endAction &#x3D; &#123; (state) in</span><br><span class="line"></span><br><span class="line">        switch state &#123;</span><br><span class="line">            case .complete(let result):</span><br><span class="line"></span><br><span class="line">                if let complete &#x3D; gcd?.complete &#123;</span><br><span class="line">                    complete(result)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if let nextGCD &#x3D; gcd?.nextGCD, let task &#x3D; nextGCD.task &#123;</span><br><span class="line">                        nextGCD.startTask(task)</span><br><span class="line">                    &#125;</span><br><span class="line">            case .error(let result):</span><br><span class="line">                if let error &#x3D; gcd?.error  &#123;</span><br><span class="line">                    error(result)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                gcd?.nextGCD?.end(.cancel)</span><br><span class="line">            case .cancel:</span><br><span class="line">                gcd?.nextGCD?.end(.cancel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gcd?.nextGCD &#x3D; nil</span><br><span class="line">        gcd &#x3D; nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否创建，防止重复创建、</li>
<li><code>complete</code> ： 执行 <code>complete</code> 处理，执行下一个任务</li>
<li><code>error</code> ： 执行 <code>error</code> 处理，取消下一个任务</li>
<li><code>cancel</code> ： 取消下一个任务 （相当于链式取消后面的所有任务）</li>
<li>清理强引用，解除引用循环，以便当前 <code>MyGCD</code> 对象释放</li>
</ul>
<p>将 <code>createEndAction()</code> 添加到 <code>complete</code>、<code>error</code>方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func next(_ task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line">    newGCD.task &#x3D; task</span><br><span class="line">    nextGCD &#x3D; newGCD</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func complete(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func error(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    error &#x3D; action</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在开始测试，给每个任务，添加 <code>complete</code> 以及 <code>error</code> 处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.complete(MyGCD.Result(200)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务1 错误: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.complete(MyGCD.Result(200)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务2 错误: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.complete(MyGCD.Result(200)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务3 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">任务1 发布</span><br><span class="line">init : 1</span><br><span class="line">init : 2</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务1 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务2 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 1</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">任务3 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们发现测试代码，写的很啰嗦，特别是 <code>Result</code> 的创建，需要写一大串，非常的不美观，现在我们对<code>Result</code>进行一下扩展，来简化我们的代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension MyGCD.Result &#123;</span><br><span class="line">    static var success: MyGCD.Result &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Result(200)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func result(_ code: Int,_ message: String &#x3D; &quot;&quot;,_ data: Any? &#x3D; nil) -&gt; MyGCD.Result &#123;</span><br><span class="line">        return Result(code,message,data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>gcd.end(.complete(MyGCD.Result(200)))</code> -&gt; <code>gcd.end(.mplete(success))</code>，感觉还是有点啰嗦，而且 <code>complete</code> 和 <code>error</code> 侧重的数据是不一样的，我们可以对<code>State</code> 进行扩展。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension MyGCD.State &#123;</span><br><span class="line">    static func sucess(_ data:Any? &#x3D; nil) -&gt; MyGCD.State &#123;</span><br><span class="line">        return .complete(.result(200, nil, data))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func error(_ code: Int,_ message: String? &#x3D; nil,_ data: Any? &#x3D; nil) -&gt; MyGCD.State &#123;</span><br><span class="line">        return .error(.result(code, message, data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改测试代码，将其中一个任务，返回错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务1 错误: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.error(404))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务2 错误: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务3 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p><code>任务2</code> 返回错误后，后续的<code>任务3</code>并没有执行，并且 <code>MyGCD</code> 的所有对象都释放了。（可以验证，<code>任务1</code>返回错误后，后续的任务也可正常取消掉）。</p>
<h2 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h2><p>实际情况下，系列任务中，只要有一个任务失败了，所有任务都需要重头再来，或者干些其他操作，基本的处理都差不多一样，那么给每一个任务都添加一样的错误处理，太不优雅了，如果能在最后一个任务那里，添加错误处理，前面的所有的任务，都进行同样的错误处理，就好了。</p>
<p>因为是从后向前传递 <code>error</code> 处理，那么 <code>MyGCD</code> 需要一个回调，当 <code>error</code> 处理赋值的时候，通知前一个任务。那么创建下一个 <code>MyGCD</code> 的时候，我们需要封装一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typealias ErrorCallback &#x3D; (@escaping ResultAction) -&gt; Void</span><br><span class="line">&#x2F;&#x2F;&#x2F; 错误处理已经添加的回调</span><br><span class="line">fileprivate var errorDidAdded : ErrorCallback?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 创建NextGCD</span><br><span class="line">func createNextGCD(_ task: @escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line">    newGCD.errorDidAdded &#x3D; &#123;[weak self] action in</span><br><span class="line">        if self?.error &#x3D;&#x3D; nil &#123;</span><br><span class="line">            self?.error(action)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            self?.transmitError(action)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newGCD.task &#x3D; task</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 传递Error处理</span><br><span class="line">func transmitError(_ action:@escaping ResultAction) &#123;</span><br><span class="line"></span><br><span class="line">    if let errorDidAdded &#x3D; errorDidAdded &#123;</span><br><span class="line">        errorDidAdded(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>next</code> 、 <code>error</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func next(_ task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    nextGCD &#x3D; createNextGCD(task)</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return nextGCD!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func error(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    error &#x3D; action</span><br><span class="line">    transmitError(action)</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改下测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.error(404))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务有 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">任务1 发布</span><br><span class="line">init : 1</span><br><span class="line">init : 2</span><br><span class="line">任务1 开始</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 结束</span><br><span class="line">任务1 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务有 错误: Result(code: 404, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 2</span><br><span class="line">deinit : 1</span><br></pre></td></tr></table></figure>

<p>错误代码正常执行了，后续任务也正常取消了，<code>error</code>传递成功。</p>
<p>下面给 <code>任务2</code> 添加 <code>error</code> 处理，看下执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.error(404))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务2 错误: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务有 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">任务1 发布</span><br><span class="line">init : 1</span><br><span class="line">任务1 开始</span><br><span class="line">init : 2</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 结束</span><br><span class="line">任务1 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务2 错误: Result(code: 404, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 2</span><br><span class="line">deinit : 1</span><br></pre></td></tr></table></figure>

<p>正常设置的 <code>error</code> 处理正常执行了，并没有被覆盖。</p>
<h2 id="2-0-完成"><a href="#2-0-完成" class="headerlink" title="2.0 完成"></a>2.0 完成</h2><p>至此 2.0 的功能完成。</p>
<h1 id="MyGCD-3-0"><a href="#MyGCD-3-0" class="headerlink" title="MyGCD 3.0"></a>MyGCD 3.0</h1><p>在日常的开发中，除了顺序执行任务，还有并发执行任务，例如下载图片，肯定是同时开始下载，所有的图片都下载完成，才能算任务结束。<code>2.0</code> 版本解决不了，批量问题，那么再来改造吧。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>首先，我们先思考下，我们的功能预期，然后才能一步一步向目标迈进，设计整个处理流程。<br>现在，我们假设一下功能预期：</p>
<ol>
<li>任务并发执行</li>
<li>所有任务完成后，回调</li>
<li>可以和前面的单任务一样，进行链式调用</li>
<li>假定并发任务中，一个任务的失败，不算整组任务的失败，（就像下载图片，允许下载失败）</li>
</ol>
<blockquote>
<p>并发执行的任务，按照前面的处理，任务都是放到GCD中执行的，因为GCD不能取消，所以即使有任务失败的也不能取消其他的任务，所以对于错误处理，只是调用回调，并不算整组任务的失败。<br>PS：并发任务我们一般也只关心，整组任务是否执行完了。</p>
</blockquote>
<p>要达到上面的要求，我们要做一下几点：</p>
<ol>
<li>任务需要单独存储，包括任务的完成以及失败回调，还有任务的状态，是否开始，取消等</li>
<li>单任务与多任务的处理需要分开，在多任务的处理中，大部分都跟单任务一样，就是添加是多个，这里我决定使用继承，后面，我们还可以做一些神奇的操作</li>
<li>关于任务的封装，之前是一个 <code>block</code>，现在是需要存储状态、回调等，而且状态需要修改，最后简单封装成一个 <code>class</code>，多任务 <code>class</code> 需要一个属性，子任务列表。</li>
</ol>
<blockquote>
<p>关于任务的封装，还有一种选择是封装成 <code>struct</code>，但是 <code>swift</code> 中 <code>struct</code> 是值类型，值类型有一个特性 <code>Copy-on-Write</code>，而任务的创建以及属性赋值，不是一次性，例如回调、状态，都是需要修改属性，很容易触发 <code>Copy-on-Write</code>，修改就会放到一个 <code>Copy</code> 的对象里面，全部修改都白费。所以改用 <code>class</code>。</p>
</blockquote>
<h2 id="任务封装"><a href="#任务封装" class="headerlink" title="任务封装"></a>任务封装</h2><p>我们列举一下，任务的属性，以及需要实现的方法：<br>任务 <code>Task</code>：</p>
<ul>
<li>状态</li>
<li>完成回调</li>
<li>错误回调</li>
<li>结束回调（任务结束，不论成功与失败）</li>
<li>任务开始</li>
<li>任务取消</li>
<li>任务完成（任务 <code>block</code> 中，任务结束）</li>
<li>任务 <code>block</code></li>
</ul>
<p>多任务 <code>MutiTask</code>：</p>
<ul>
<li>多任务（任务数组）</li>
</ul>
<p>因为单任务 <code>MyGCD</code> 与 多任务 <code>MyGCD2</code> 是继承关系，属性 <code>task</code> ，在不同的类里面，<code>task</code>代表不同的任务，而且单任务 <code>Task</code>、多任务 <code>MutiTask</code> 之间有好多共同的地方，这时抽象一个 <code>OneTask</code> 协议，属性 <code>task</code> 标记类型为 <code>OneTask</code>，具体的类型，由类自己实现。</p>
<blockquote>
<p>单任务 <code>MyGCD</code> 与 多任务 <code>MyGCD2</code> 的名字有点不合适，改个名字吧，单任务 <code>AsyncTask</code> 、 多任务 <code>AsyncMutiTask</code>。</p>
</blockquote>
<p>协议 <code>OneTask</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protocol OneTask &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务状态</span><br><span class="line">    var state: MyGCD.State &#123;get set&#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    var complete: MyGCD.ResultAction? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    var error: MyGCD.ResultAction? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束回调</span><br><span class="line">    var endAction: MyGCD.EndAction? &#123; get set &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 开始</span><br><span class="line">    func start()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter state: 结束的状态</span><br><span class="line">    func end(_ state:MyGCD.State)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取消</span><br><span class="line">    func cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务 <code>Task</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">class Task:OneTask &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务Block</span><br><span class="line">    var task: TaskAction</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务状态</span><br><span class="line">    var state: State &#x3D; .idle</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    var complete: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    var error: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束回调</span><br><span class="line">    var endAction: EndAction?</span><br><span class="line"></span><br><span class="line">    init(_ task: @escaping TaskAction) &#123;</span><br><span class="line">        self.task &#x3D; task</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func start() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func end(_ state: State) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func cancel() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务 <code>MutiTask</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MutiTask:OneTask &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;任务List</span><br><span class="line">    var tasks: [Task] &#x3D; [Task]()</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 状态</span><br><span class="line">    var state: State &#x3D; .idle</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    var complete: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    var error: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束回调</span><br><span class="line">    var endAction: AsyncTask.EndAction?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束的任务个数</span><br><span class="line">    var endCount &#x3D; 0</span><br><span class="line"></span><br><span class="line">    init(_ tasks: [Task] &#x3D; [], complete: ResultAction? &#x3D; nil, error: ResultAction? &#x3D; nil) &#123;</span><br><span class="line">        self.tasks.append(contentsOf: tasks)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func add(_ task: Task) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func start() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func end(_ state: State) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func cancel() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>任务的状态：<code>完成</code> 、<code>错误</code> 、<code>取消</code>，多任务时，状态有点不够用，未添加时，应该是<code>空闲</code>状态，开始执行任务时，应该是<code>执行中</code>，完成时，是所有任务都完成，<code>完成所有</code>，下面是扩展后的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 任务状态</span><br><span class="line">enum State &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 空闲</span><br><span class="line">    case idle</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务中</span><br><span class="line">    case doing</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    case complete(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    case error(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取消</span><br><span class="line">    case cancel</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 多任务</span><br><span class="line">    case completeAll([Result])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>结果在多任务的时候也要添加一个多任务的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 结果</span><br><span class="line">struct Result &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 状态码</span><br><span class="line">    var code: Int</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 信息</span><br><span class="line">    var message: String</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 数据</span><br><span class="line">    var data: Any?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 多任务结果</span><br><span class="line">    var results: [Result]</span><br><span class="line"></span><br><span class="line">    init(_ code: Int,_ message: String &#x3D; &quot;&quot;,_ data: Any? &#x3D; nil,_ results: [Result] &#x3D; []) &#123;</span><br><span class="line">        self.code &#x3D; code</span><br><span class="line">        self.message &#x3D; message</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">        self.results &#x3D; results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展 <code>extension</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extension AsyncTask.Result &#123;</span><br><span class="line">    static func results(_ code: Int,_ message: String?,_ data: Any? &#x3D; nil,_ results: [AsyncTask.Result] &#x3D; []) -&gt; AsyncTask.Result &#123;</span><br><span class="line">        return AsyncTask.Result(code,message ?? &quot;&quot;,data,results)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func results(_ results: [AsyncTask.Result],_ code: Int &#x3D; 200,_ message: String? &#x3D; nil) -&gt; AsyncTask.Result &#123;</span><br><span class="line">        return AsyncTask.Result(code,message ?? &quot;&quot;,nil,results)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Task-实现"><a href="#Task-实现" class="headerlink" title="Task 实现"></a>Task 实现</h2><p>现在来实现<code>Task</code>，填充所有逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func start() &#123;</span><br><span class="line"></span><br><span class="line">    lock()</span><br><span class="line">    guard case .idle &#x3D; state else &#123;</span><br><span class="line">        unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state &#x3D; .doing</span><br><span class="line">    unlock()</span><br><span class="line"></span><br><span class="line">    AsyncTask.startTask &#123; [weak self] in</span><br><span class="line">        guard let self &#x3D; self else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.task(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lock()</code> 、<code>unlock()</code> 线程锁，因为任务是异步执行，状态的判断很容易有多线程问题，数据不一致，每次判断都得加锁，保证数据的线程安全。<br><code>AsyncTask.startTask</code> 是一个类方法，所有的任务都是异步执行，所以声明了一个类属性的 <code>queue</code> ，一个并发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 队列</span><br><span class="line">fileprivate static var queue: DispatchQueue &#x3D; DispatchQueue(label: &quot;AsyncTask&quot;, qos: .default, attributes: .concurrent)</span><br><span class="line">&#x2F;&#x2F;&#x2F; 开始任务</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Parameter action: 任务 block</span><br><span class="line">fileprivate static func startTask(_ action:@escaping Action) &#123;</span><br><span class="line">    self.queue.async(execute: action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现完成方法，任务执行后，需要手动调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func end(_ state:State) &#123;</span><br><span class="line"></span><br><span class="line">    lock()</span><br><span class="line">    self.state &#x3D; state</span><br><span class="line">    unlock()</span><br><span class="line"></span><br><span class="line">    switch state &#123;</span><br><span class="line">        case .complete(let result):</span><br><span class="line">            if let complete &#x3D; complete &#123;</span><br><span class="line">                complete(result)</span><br><span class="line">            &#125;</span><br><span class="line">        case .error(let result):</span><br><span class="line">            if let error &#x3D; error  &#123;</span><br><span class="line">                error(result)</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if let endAction &#x3D; endAction &#123;</span><br><span class="line">        endAction(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现取消方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func cancel() &#123;</span><br><span class="line"></span><br><span class="line">    lock()</span><br><span class="line">    guard case .idle &#x3D; state else &#123;</span><br><span class="line">        unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state &#x3D; .cancel</span><br><span class="line">    unlock()</span><br><span class="line"></span><br><span class="line">    if let endAction &#x3D; endAction &#123;</span><br><span class="line">        endAction(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MutiTask-实现"><a href="#MutiTask-实现" class="headerlink" title="MutiTask 实现"></a>MutiTask 实现</h2><p>多任务的核心就是添加子任务，绑定一些回调，通过回调来掌控子任务的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func add(_ task:Task) &#123;</span><br><span class="line">    lock()</span><br><span class="line">    guard case .idle &#x3D; state else &#123;</span><br><span class="line">        print(&quot;MutiTask is doing, can&#39;t add new task!&quot;)</span><br><span class="line">        unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    unlock()</span><br><span class="line"></span><br><span class="line">    self.tasks.append(task)</span><br><span class="line"></span><br><span class="line">    task.complete &#x3D; &#123; [weak self] (result) in</span><br><span class="line">        guard let self &#x3D; self else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if let complete &#x3D; self.complete &#123;</span><br><span class="line">            complete(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task.error &#x3D; &#123; [weak self] (result) in</span><br><span class="line">        guard let self &#x3D; self else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if let error &#x3D; self.error &#123;</span><br><span class="line">            error(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task.endAction &#x3D; &#123; [weak self] (state) in</span><br><span class="line">        guard let self &#x3D; self else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.lock()</span><br><span class="line">        self.endCount +&#x3D; 1</span><br><span class="line">        self.unlock()</span><br><span class="line">        </span><br><span class="line">        self.end(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加方法，开始的判断，是假设，有任务开始后，禁止添加，减少复杂情况的出现，保证我们的任务是简单的多任务并发。<br>在<code>完成</code> <code>错误</code> 的回调里面，调用 <code>MutiTask</code> 相应的回调，相当于 <code>MutiTask</code> 中的回调是通用回调。<br><code>endAction</code>回调中，记录已完成的子任务数量，并调用<code>end(state)</code>方法。</p>
</blockquote>
<p>下面开始实现开始方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func start() &#123;</span><br><span class="line">    lock()</span><br><span class="line">    if case .idle &#x3D; state &#123;</span><br><span class="line">        state &#x3D; .doing</span><br><span class="line">    &#125;</span><br><span class="line">    unlock()</span><br><span class="line"></span><br><span class="line">    for task in tasks &#123;</span><br><span class="line">        task.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结束方法，这里主要是子方法完成后，会回调到这里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func end(_ state: State) &#123;</span><br><span class="line">    lock()</span><br><span class="line">    guard case .doing &#x3D; self.state else &#123;</span><br><span class="line">        unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let count &#x3D; endCount</span><br><span class="line">    unlock()</span><br><span class="line"></span><br><span class="line">    if count &#x3D;&#x3D; tasks.count &#123;</span><br><span class="line"></span><br><span class="line">        var list &#x3D; [Result]()</span><br><span class="line">        for task in tasks &#123;</span><br><span class="line"></span><br><span class="line">            switch task.state &#123;</span><br><span class="line">                case .complete(let result):</span><br><span class="line">                    list.append(result)</span><br><span class="line">                case .error(let result):</span><br><span class="line">                    list.append(result)</span><br><span class="line">                default:</span><br><span class="line">                    break</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        self.state &#x3D; .completeAll(list)</span><br><span class="line"></span><br><span class="line">        if let complete &#x3D; self.complete &#123;</span><br><span class="line">            complete(.results(list))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if let endAction &#x3D; endAction &#123;</span><br><span class="line">            endAction(self.state)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据已完成的子任务数，当所有的任务都完成后，再统调用一个 <code>complete</code> 回调，传递所有子任务的状态。<br>PS：如有需要可以单独顶一个 <code>completeAll</code> 回调，来处理所有任务执行的结果。</p>
</blockquote>
<p>实现取消方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func cancel() &#123;</span><br><span class="line">    lock()</span><br><span class="line">    self.state &#x3D; .cancel</span><br><span class="line">    unlock()</span><br><span class="line"></span><br><span class="line">    for task in tasks &#123;</span><br><span class="line">        task.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AsyncTask-实现"><a href="#AsyncTask-实现" class="headerlink" title="AsyncTask 实现"></a>AsyncTask 实现</h2><p>任务处理完了，下面就需要实现我们的 <code>AsyncTask</code>，由于任务的处理都抽离出来了，本身的处理就少了很多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">class AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F;记录总创建的个数</span><br><span class="line">    fileprivate static var count:Int &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 标记，区分每个不同的对象</span><br><span class="line">    fileprivate var tag: Int</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 下一个 Task</span><br><span class="line">    fileprivate var nextTask: AsyncTask?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">    fileprivate var task: OneTask?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误处理已经添加的回调</span><br><span class="line">    fileprivate var errorDidAdded: ErrorCallback?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 队列</span><br><span class="line">    fileprivate static var queue: DispatchQueue &#x3D; DispatchQueue(label: &quot;AsyncTask&quot;, qos: .default, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line"></span><br><span class="line">        tag &#x3D; AsyncTask.count</span><br><span class="line"></span><br><span class="line">        print(&quot;init : \(tag)&quot;)</span><br><span class="line"></span><br><span class="line">        AsyncTask.count +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;deinit : \(tag)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; MARK: 任务处理</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter task: block 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: AsyncTask</span><br><span class="line">    @discardableResult</span><br><span class="line">    func task(_ task:@escaping TaskAction) -&gt; AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">        addTask(task)</span><br><span class="line">        start()</span><br><span class="line"></span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 开始任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: AsyncTask</span><br><span class="line">    @discardableResult</span><br><span class="line">    func start() -&gt; AsyncTask &#123;</span><br><span class="line">        task?.start()</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 下一个任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: block 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">    @discardableResult</span><br><span class="line">    func next(_ task:@escaping TaskAction) -&gt; AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">        nextTask &#x3D; createTask(task)</span><br><span class="line"></span><br><span class="line">        return nextTask!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: block 处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">    @discardableResult</span><br><span class="line">    func complete(_ action:@escaping ResultAction) -&gt; AsyncTask &#123;</span><br><span class="line">        task?.complete &#x3D; action</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: block 处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">    @discardableResult</span><br><span class="line">    func error(_ action:@escaping ResultAction) -&gt; AsyncTask &#123;</span><br><span class="line">        task?.error &#x3D; action</span><br><span class="line">        transmitError(action)</span><br><span class="line"></span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务结束</span><br><span class="line">    fileprivate func end(_ state: State) &#123;</span><br><span class="line">        switch state &#123;</span><br><span class="line">            case .complete(_):</span><br><span class="line">                fallthrough</span><br><span class="line">            case .completeAll(_):</span><br><span class="line">                if let nextTask &#x3D; nextTask &#123;</span><br><span class="line">                    nextTask.start()</span><br><span class="line">            &#125;</span><br><span class="line">            case .error(_):</span><br><span class="line">                nextTask?.task?.cancel()</span><br><span class="line">            case .cancel:</span><br><span class="line">                nextTask?.task?.cancel()</span><br><span class="line">            default:</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextTask &#x3D; nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; MARK: 私有函数</span><br><span class="line">    fileprivate func addTask(_ task:@escaping TaskAction) &#123;</span><br><span class="line">        self.task &#x3D; Task(task)</span><br><span class="line"></span><br><span class="line">        var gcd:AsyncTask? &#x3D; self</span><br><span class="line">        self.task?.endAction &#x3D; &#123; state in</span><br><span class="line">            gcd?.end(state)</span><br><span class="line"></span><br><span class="line">            gcd &#x3D; nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个方法的实现，都比较简单，就不一一描述了。</p>
<h2 id="AsyncMutiTask-实现"><a href="#AsyncMutiTask-实现" class="headerlink" title="AsyncMutiTask 实现"></a>AsyncMutiTask 实现</h2><p><code>AsyncMutiTask</code> 与 <code>AsyncTask</code> 的区别就是，添加多任务，执行多任务，直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class AsyncMutiTask: AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line"></span><br><span class="line">        self.task &#x3D; MutiTask()</span><br><span class="line">        var gcd:AsyncTask? &#x3D; self</span><br><span class="line">        self.task?.endAction &#x3D; &#123; state in</span><br><span class="line">            gcd?.end(state)</span><br><span class="line"></span><br><span class="line">            gcd &#x3D; nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter tasks: block 数组</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: AsyncTask</span><br><span class="line">    @discardableResult</span><br><span class="line">    func tasks(_ tasks:[TaskAction]) -&gt; AsyncTask &#123;</span><br><span class="line">        addTasks(tasks)</span><br><span class="line">        start()</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 开始任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: AsyncTask</span><br><span class="line">    @discardableResult</span><br><span class="line">    override func start() -&gt; AsyncTask &#123;</span><br><span class="line">        self.task?.start()</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; MARK: 私有函数</span><br><span class="line">    fileprivate func addTasks(_ tasks:[TaskAction]) &#123;</span><br><span class="line">        guard let mutiTask &#x3D; self.task as? MutiTask else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for task in tasks &#123;</span><br><span class="line">            mutiTask.add(Task(task))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fileprivate func addTask(_ task: @escaping TaskAction) &#123;</span><br><span class="line">        guard let mutiTask &#x3D; self.task as? MutiTask else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        mutiTask.add(Task(task))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他大部分逻辑都抽离到 <code>MutiTask</code>中了，实际代码很少。</p>
<p>下面添加一个一些辅助函数，还有快捷函数，方便快捷调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MARK: 私有辅助函数</span><br><span class="line">extension AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 创建Task</span><br><span class="line">    fileprivate func createTask(_ task: @escaping TaskAction) -&gt; AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">        let newTask &#x3D; AsyncTask()</span><br><span class="line">        newTask.errorDidAdded &#x3D; &#123;[weak self] action in</span><br><span class="line">            if self?.task?.error &#x3D;&#x3D; nil &#123;</span><br><span class="line">                self?.error(action)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                self?.transmitError(action)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newTask.addTask(task)</span><br><span class="line"></span><br><span class="line">        return newTask</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 创建MutiTask</span><br><span class="line">    fileprivate func createMutiTask(_ tasks:[TaskAction]) -&gt; AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">        let newTask &#x3D; AsyncMutiTask()</span><br><span class="line">        newTask.errorDidAdded &#x3D; &#123;[weak self] action in</span><br><span class="line">            if self?.task?.error &#x3D;&#x3D; nil &#123;</span><br><span class="line">                self?.error(action)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                self?.transmitError(action)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newTask.addTasks(tasks)</span><br><span class="line"></span><br><span class="line">        return newTask</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 传递Error处理</span><br><span class="line">    fileprivate func transmitError(_ action:@escaping ResultAction) &#123;</span><br><span class="line"></span><br><span class="line">        if let errorDidAdded &#x3D; errorDidAdded &#123;</span><br><span class="line">            errorDidAdded(action)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 开始任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: 任务 block</span><br><span class="line">    fileprivate static func startTask(_ action:@escaping Action) &#123;</span><br><span class="line">        self.queue.async(execute: action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; MARK: 快捷方法</span><br><span class="line">extension AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 下一组任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter tasks: 任务数组</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: AsyncTask</span><br><span class="line">    func nexts(_ tasks:[TaskAction]) -&gt; AsyncTask &#123;</span><br><span class="line"></span><br><span class="line">        nextTask &#x3D; createMutiTask(tasks)</span><br><span class="line"></span><br><span class="line">        return nextTask!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter task: block 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: AsyncTask</span><br><span class="line">    @discardableResult</span><br><span class="line">    static func task(_ task:@escaping TaskAction) -&gt; AsyncTask &#123;</span><br><span class="line">        return AsyncTask().task(task)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter tasks: block 数组</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: AsyncTask</span><br><span class="line">    @discardableResult</span><br><span class="line">    static func tasks(_ tasks:[TaskAction]) -&gt; AsyncTask &#123;</span><br><span class="line">        return AsyncMutiTask().tasks(tasks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">AsyncTask.task &#123; task in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        task.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.nexts([</span><br><span class="line">    &#123; task in</span><br><span class="line">        createTask(&quot;任务2_1&quot;) &#123;</span><br><span class="line">            task.end(.complete(.result(200, &quot;任务2_1 完成&quot;)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&#123; task in</span><br><span class="line">        createTask(&quot;任务2_2&quot;) &#123;</span><br><span class="line">            task.end(.error(404,&quot;任务2_2 完成&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&#123; task in</span><br><span class="line">        createTask(&quot;任务2_3&quot;) &#123;</span><br><span class="line">            task.end(.complete(.result(200, &quot;任务2_3 完成&quot;)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&#123; task in</span><br><span class="line">        createTask(&quot;任务2_4&quot;) &#123;</span><br><span class="line">            task.end(.error(404,&quot;任务2_4 错误&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,]).complete&#123; (result) in</span><br><span class="line">        print(&quot;任务 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务有2 错误: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; task in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        task.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务有 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">init : 1</span><br><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">init : 2</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 结束</span><br><span class="line">任务1 complete: Result(code: 200, message: &quot;&quot;, data: nil, results: [])</span><br><span class="line">deinit : 0</span><br><span class="line">任务2_1 发布</span><br><span class="line">任务2_2 发布</span><br><span class="line">任务2_3 发布</span><br><span class="line">任务2_2 开始</span><br><span class="line">任务2_3 开始</span><br><span class="line">任务2_1 开始</span><br><span class="line">任务2_4 发布</span><br><span class="line">任务2_4 开始</span><br><span class="line">任务2_2 结束</span><br><span class="line">任务2_4 结束</span><br><span class="line">任务2_1 结束</span><br><span class="line">任务有2 错误: Result(code: 404, message: &quot;任务2_2 完成&quot;, data: nil, results: [])</span><br><span class="line">任务2_3 结束</span><br><span class="line">任务有2 错误: Result(code: 404, message: &quot;任务2_4 错误&quot;, data: nil, results: [])</span><br><span class="line">任务 complete: Result(code: 200, message: &quot;任务2_1 完成&quot;, data: nil, results: [])</span><br><span class="line">任务 complete: Result(code: 200, message: &quot;任务2_3 完成&quot;, data: nil, results: [])</span><br><span class="line">任务 complete: Result(code: 200, message: &quot;&quot;, data: nil, results: [MLibDemo.AsyncTask.Result(code: 200, message: &quot;任务2_1 完成&quot;, data: nil, results: []), MLibDemo.AsyncTask.Result(code: 404, message: &quot;任务2_2 完成&quot;, data: nil, results: []), MLibDemo.AsyncTask.Result(code: 200, message: &quot;任务2_3 完成&quot;, data: nil, results: []), MLibDemo.AsyncTask.Result(code: 404, message: &quot;任务2_4 错误&quot;, data: nil, results: [])])</span><br><span class="line">deinit : 1</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">任务3 complete: Result(code: 200, message: &quot;&quot;, data: nil, results: [])</span><br><span class="line">deinit : 2</span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>前面还能说一下思路，到 <code>3.0</code> 已经变成直接上代码，中间试验的时候碰到的问题，基本都写下了，整个解决回调地狱，解决的关键其实是在前面，后面更多是试验，然后封装。</p>
<blockquote>
<p>PS：希望对大家有帮助，文笔太差，让大家见笑了。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/zhrmghgfff/MTips.git" target="_blank" rel="noopener">代码</a>我已上传GitHub，会略有修改，仅供参考</p>

            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2020/05/28/iOS-Runtime%E6%8E%A2%E7%A9%B6/">iOS Runtime探究</a>
            </div>
            <p class="sub">May 28 2020</p>
            <div class="post-content">
                <blockquote>
<p>使用 Objective-C 开发 iOS 应用很多年了，一致打交道的都是UI部分，平时看文章也经常会有 runtime 的字眼跳出来，也知道一些 runtime 的相关内容，例如消息发送、消息转发、消息替换，平时交流中也能说上来个一二，但是总体的印象还是混沌模糊的，一直没有细致的静下心来，去了解 runtime , 了解runtime是怎么运行的，那些功能是怎么实现的。</p>
<blockquote>
<p>那么接下来</p>
</blockquote>
</blockquote>
<h1 id="什么是Runtime"><a href="#什么是Runtime" class="headerlink" title="什么是Runtime"></a>什么是Runtime</h1><p>具体了解还是得看官方文档，<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a>，虽然文档不更新了，但是描述还是可以看看的。</p>
<blockquote>
<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
</blockquote>
<p>硬核翻译一下:-) </p>
<blockquote>
<p>Objective-C语言尽可能地将编译时间和链接时间推迟到运行时。只要有可能，它就会动态地执行操作。这意味着该语言不仅需要一个编译器，还需要一个运行时系统来执行编译后的代码。运行时系统 <strong>runtime</strong> 作为Objective-C语言的一种操作系统;它使Objective-C语言的动态特性生效。</p>
</blockquote>
<p>简单组织一下就是：</p>
<ul>
<li><strong>runtime</strong> 是一个系统，通过这个系统，Objective-C 可以将一些决议，放到运行时来处理，而不是在编译、链接时就定死了。这样在运行时处理决议的特性，就是 Objective-C 的动态特性。</li>
</ul>
<blockquote>
<p>PS:英文水平不好的，可以先google翻译，然后再看原文，发现翻译大部分时候，都是狗屁不通😹</p>
</blockquote>
<p>接下来继续阅读文档，发现有几章介绍Rumtime:</p>
<ul>
<li>Runtime Versions and Platforms : <strong>runtime的版本与平台</strong></li>
<li>Interacting with the Runtime : <strong>与runtime的交互</strong></li>
<li>Messaging : <strong>消息传递</strong></li>
<li>Dynamic Method Resolution : <strong>动态方法解析</strong></li>
<li>Message Forwarding : <strong>消息转发</strong></li>
<li>Type Encodings : <strong>类型编码</strong></li>
<li>Declared Properties : <strong>声明属性</strong></li>
</ul>
<blockquote>
<p>这几章基本介绍了 runtime 相关功能，相当于一个总纲，每当没有头绪的时候都可以回来看看</p>
</blockquote>
<p>在<code>与runtime的交互</code>这章中，发现三个与 runtime 系统交互的途径：</p>
<ul>
<li>through Objective-C source code : <strong>通过 Objective-C 源码</strong></li>
<li>through methods defined in the NSObject class of the Foundation framework : <strong>通过 Foundation 框架中的 NSObject 类中定义的方法</strong></li>
<li>through direct calls to runtime functions : <strong>直接通过 runtime 的方法</strong></li>
</ul>
<p>接下来阅读相关内容发现，<strong>runtime</strong> 其实是一个<strong>动态共享库</strong> （真实名字是libobjc），一般放在<code>/usr/include/objc</code>下，runtime 相关的方法可以参考<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc" target="_blank" rel="noopener">Objective-C Runtime Reference</a>，里面介绍了所有的运行时方法。</p>
<p>那么我们要研究 runtime 如何加载，如何处理，只看介绍，还是有点虚，有一个程序员说：<code>Talk is cheap. Show me the code.</code>，看源码才能真切的知道、了解，它是怎么做的。</p>
<blockquote>
<p>如果去查找源码？</p>
</blockquote>
<h1 id="Runtime-源码"><a href="#Runtime-源码" class="headerlink" title="Runtime 源码"></a>Runtime 源码</h1><p>苹果有专门的源码开源网址：<a href="https://opensource.apple.com/" target="_blank" rel="noopener">opensource</a>,选择一个Mac 系统版本，点进去，发现有好多库，搜索<code>objc</code>，找一个<code>objc</code>，后面的数字是他的版本，然后下载，解压，就拿到 <strong>runtime</strong> 的源码了。</p>
<p>解压后，进入源码文件夹（我下载的是 <strong>objc4-781.2</strong>），打开 <strong>objc.xcodeproj</strong>，就可以开始我们的源码解析之路了。</p>
<h2 id="编译-objc-源码"><a href="#编译-objc-源码" class="headerlink" title="编译 objc 源码"></a>编译 objc 源码</h2><p>为了跟踪代码运行，最好还是编辑下源码，实际调试跟踪方法的运行，更好理解整个 <strong>runtime</strong> 的实现。</p>
<h3 id="编译中遇到的问题"><a href="#编译中遇到的问题" class="headerlink" title="编译中遇到的问题"></a>编译中遇到的问题</h3><h4 id="unable-to-find-SDK-‘macosx-internal‘"><a href="#unable-to-find-SDK-‘macosx-internal‘" class="headerlink" title="unable to find SDK ‘macosx.internal‘"></a>unable to find SDK ‘<strong>macosx.internal</strong>‘</h4><p>需要 macOS 的 SDK，直接在工程里面修改配置，<code>Build Settings</code> -&gt; <code>Base SDK</code> ， 选择当前的系统的Mac OS SDK，我的系统是<code>10.15.4</code>，就选择<code>macOS 10.15</code></p>
<h4 id="‘sys-reason-h‘-file-not-found"><a href="#‘sys-reason-h‘-file-not-found" class="headerlink" title="‘sys/reason.h‘ file not found"></a>‘<strong>sys/reason.h</strong>‘ file not found</h4><p>缺少 <code>sys</code> 相关的头文件，这些头文件其实是 <a href="https://zh.wikipedia.org/wiki/XNU" target="_blank" rel="noopener">苹果系统内核 XNU</a> 的头文件，同样的可以去 <a href="https://opensource.apple.com/" target="_blank" rel="noopener">opensource</a> 上，下载到 <code>xnu</code> (下载与 <strong>objc</strong> 同一目录下 <strong>xnu</strong> 即可)，在工程里面，新建一个文件夹，将缺少的文件复制进去。</p>
<blockquote>
<p>PS：工程下的新建目录，例如新建的目录为 <strong>Commons</strong>，新建 <strong>sys</strong> 目录，放置 <strong>sys</strong> 下的文件，最后添加头文件的搜索路径为 <code>$(SRCROOT)/Commons</code>。其他的文件缺失问题，同理操作。</p>
</blockquote>
<p>可以通过谷歌中输入<code>reason.h site:opensource.apple.com</code> 定向检索，文件在哪个库里面。<br>依次需要下载的库为：<code>xnu</code>，<code>dyld</code>，<code>libplatform</code>，<code>libpthread</code>，<code>libc (825版本)</code></p>
<p>一些文件需要特殊处理：</p>
<ul>
<li><p>dyld_priv.h   去掉 bridgeos(3.0) </p>
<ul>
<li>bridgeOS是watchOS的经过重大修改的变体，可在集成的iBridge设备上运行。</li>
<li>iBridge是Mac的嵌入式处理设备系列。当前有两个主要变体。<ul>
<li>iBridge T1-在2016年带Touch Bar的MacBook Pro中发现。</li>
<li>iBridge T2-在iMac Pro和更高版本中找到。</li>
</ul>
</li>
<li>跟我探究runtime关系不大，直接去掉</li>
</ul>
</li>
<li><p>lock_private.h  去掉 bridgeos(4.0) </p>
</li>
<li><p>CrashReporterClient.h 增加宏定义<br><code>#define LIBC_NO_LIBCRASHREPORTERCLIENT</code></p>
</li>
</ul>
<ul>
<li>pthread_machdep.h<br>  这个头文件是在libc(825版本)中的，825之后的版本，已经没有此文件了，跟 objc对应libc库，版本比825高，会出现一些重复定义的东西，例如一些宏，还有函数，直接注释掉pthread_machdep.h的定义即可。</li>
</ul>
<h4 id="Use-of-undeclared-identifier-‘DYLD-MACOSX-VERSION-10-13’"><a href="#Use-of-undeclared-identifier-‘DYLD-MACOSX-VERSION-10-13’" class="headerlink" title="Use of undeclared identifier ‘DYLD_MACOSX_VERSION_10_13’"></a>Use of undeclared identifier ‘<strong>DYLD_MACOSX_VERSION_10_13</strong>’</h4><p>这是MacOS对应的版本宏，定义一下即可，google查找到的<a href="https://docs.rs/goblin/0.0.13/i686-pc-windows-msvc/goblin/mach/constants/" target="_blank" rel="noopener">版本信息</a></p>
<ul>
<li>dyld_priv.h</li>
</ul>
<blockquote>
<p>宏定义习惯写成16进制<br><code>#define DYLD_MACOSX_VERSION_10_11 0x000A0B00</code><br><code>#define DYLD_MACOSX_VERSION_10_12 0x000A0C00</code><br><code>#define DYLD_MACOSX_VERSION_10_13 0x000A0D00</code><br><code>#define DYLD_MACOSX_VERSION_10_14 0x000A0E00</code></p>
</blockquote>
<h4 id="can’t-open-order-file-libobjc-order"><a href="#can’t-open-order-file-libobjc-order" class="headerlink" title="can’t open order file: libobjc.order"></a>can’t open order file: <strong>libobjc.order</strong></h4><p>修改工程配置，添加<code>libobjc.order</code>的路径，<code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Settings</code>，<code>Order file</code> -&gt; <code>$(SRCROOT)/libobjc.order</code></p>
<h4 id="Library-not-found-for-lCrashReporterClient"><a href="#Library-not-found-for-lCrashReporterClient" class="headerlink" title="Library not found for -lCrashReporterClient"></a>Library not found for <strong>-lCrashReporterClient</strong></h4><p>我们不需要崩溃上报，修改配置去掉<code>-lCrashReporterClient</code>，在 <code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Settings</code> -&gt; <code>Linking</code> -&gt; <code>Other Linker Flags</code>，删除所有的<code>-lCrashReporterClient</code></p>
<h4 id="SDK-“macosx-internal”-cannot-be-located"><a href="#SDK-“macosx-internal”-cannot-be-located" class="headerlink" title="SDK “macosx.internal” cannot be located."></a>SDK “macosx.internal” cannot be located.</h4><p>build脚本出现了问题，在 <code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Phases</code> -&gt; <code>Run Script(markgc)</code>中，修改 <code>macosx.internal</code> 为 <code>macosx</code>。</p>
<h3 id="编译成功。"><a href="#编译成功。" class="headerlink" title="编译成功。"></a>编译成功。</h3><h2 id="新建调试的Target"><a href="#新建调试的Target" class="headerlink" title="新建调试的Target"></a>新建调试的Target</h2><p>选择 <code>macOS</code> -&gt; <code>Application</code> -&gt; <code>Command Line Tool</code>，命名为<code>TestRuntime</code><br>关联 <strong>objc</strong> 库：</p>
<ul>
<li><code>target</code> -&gt; <code>TestRuntime</code> -&gt; <code>Build Phases</code> -&gt; <code>Dependencies</code>，添加依赖 <code>objc</code>。</li>
<li><code>target</code> -&gt; <code>TestRuntime</code> -&gt; <code>Build Phases</code> -&gt; <code>Link Binary With Libraries</code>，添加 <code>libobjc.A.dylib</code></li>
</ul>
<blockquote>
<p>在Xcode 11中，默认的 target 是没有权限进行断点调试的，需要修改配置，<code>target</code> -&gt; <code>objc</code> -&gt; <code>Build Settings</code> -&gt; <code>Enable Hardened Runtime</code> -&gt; <code>NO</code></p>
</blockquote>
<h3 id="启动，断点成功"><a href="#启动，断点成功" class="headerlink" title="启动，断点成功"></a>启动，断点成功</h3><p>这样就可以就行调试了。</p>
<h3 id="直接断点进入-objc-源代码"><a href="#直接断点进入-objc-源代码" class="headerlink" title="直接断点进入 objc 源代码"></a>直接断点进入 objc 源代码</h3><p>直接新建 <code>iOS App</code>，进行代码调试，目前还做不到，有好多错误，后续再进行补充。<code>step by step</code>跟踪代码运行，才能更好的理解代码原理。不能的话，就只能依靠代码经验来理解了，难度上升了一些。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>接下来就开始源码解析了。先从感兴趣的地方开始，第一个选择 <code>objc_msgSend</code>，这是 <code>runtime</code> 的精髓所在。</p>
<blockquote>
<p>源码版本 <code>objc4-781.2</code>，版本不同，具体的实现会有差异，请注意。</p>
</blockquote>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><p><code>objc_msgSend</code>，Objective-C 中所有对象的方法调用，都是由它来进行间接调用的。解析<code>objc_msgSend</code>，首先需要找到它的实现。</p>
<h3 id="怎么找到objc-msgSend的实现？"><a href="#怎么找到objc-msgSend的实现？" class="headerlink" title="怎么找到objc_msgSend的实现？"></a>怎么找到objc_msgSend的实现？</h3><p>在调试的Target中，在main函数中，随便新建一个对象，调用它的方法，然后进行断点：<br><img src="/images/%E6%88%AA%E5%B1%8F2020-06-01_%E4%B8%8B%E5%8D%881.55.40.png" alt=""></p>
<p>运行程序，在断点处中断，然后按住<code>ctrl</code>键，按f7（其实就是 <code>debug</code> 下的 <code>Step Into Instruction</code>的快捷键），断点处会一直闪烁，继续按，直到跳转到一个新的页面。<br><img src="/images/%E6%88%AA%E5%B1%8F2020-06-01_%E4%B8%8B%E5%8D%882.06.08.png" alt=""></p>
<ul>
<li>上图 <strong>1</strong> 处，可以看到<code>ENTRY _objc_msgSend</code>，这就是 <code>objc_msgSend</code> 的代码实现，而且还是汇编写。</li>
<li>上图 <strong>2</strong> 处，<code>objc-msg-x86_64.s</code>，表示此汇编文件，是为 <code>x86_64</code> 平台编写的，因为我的调试程序是 <code>macOS Command Line Tool</code>。</li>
</ul>
<blockquote>
<p><code>ENTRY</code> 是汇编实现的入口，同样的还有 <code>STATIC_ENTRY</code>，对应的就是 <code>END_ENTRY</code>。</p>
</blockquote>
<p>那么怎么找到 <code>iOS</code> 使用的源码的呢，其实从命名上就可以，很快找到 <code>iOS</code>（最新的就是<code>arm64</code>） 对应的源码，<code>objc-msg-arm64.s</code>，然后搜索 <code>ENTRY _objc_msgSend</code>，就找到了 <code>_objc_msgSend</code> 的实现，接下来就是源码的分析了。</p>
<h3 id="objc-msgSend-源码分析"><a href="#objc-msgSend-源码分析" class="headerlink" title="_objc_msgSend 源码分析"></a>_objc_msgSend 源码分析</h3><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	cmp	p0, #0			&#x2F;&#x2F; nil check and tagged pointer check nil检测和被标记的指针检测</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">	b.le	LNilOrTagged		&#x2F;&#x2F;  (MSB tagged pointer looks negative MSB标记的指针看起来像是负的 )</span><br><span class="line">#else</span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line">#endif</span><br><span class="line">	ldr	p13, [x0]		&#x2F;&#x2F; p13 &#x3D; isa 读取 isa</span><br><span class="line">	GetClassFromIsa_p16 p13		&#x2F;&#x2F; p16 &#x3D; class 通过 isa 获取 class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend &#x2F;&#x2F;通过 NORMAL 模式，缓存查找</span><br></pre></td></tr></table></figure>

<ol>
<li>首先进行对象指针的判断，判读是不是空指针</li>
<li>不是空指针，再进行标记指针的检测，（在测试环境下，会对指针进行标记，用于信息调试）。</li>
<li>是空指针，直接走 <code>LReturnZero</code>，就是直接返回（清空段寄存器状态）。</li>
<li>读取isa</li>
<li>通过 isa 获取 class</li>
<li>进行缓存查找 <code>CacheLookup</code>。</li>
</ol>
<h4 id="CacheLookup-缓存查找"><a href="#CacheLookup-缓存查找" class="headerlink" title="CacheLookup 缓存查找"></a>CacheLookup 缓存查找</h4><p>代码搜索<code>CacheLookup</code>，发现是一个宏 <code>.macro CacheLookup</code>，具体实现全是汇编（有兴趣的可以看看，我是看不懂），在宏定义的上面有一段关于 <code>CacheLookup</code>的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * CacheLookup NORMAL|GETIMP|LOOKUP &lt;function&gt;</span><br><span class="line"> * 模式有三种：</span><br><span class="line"> * NORMAL 普通</span><br><span class="line"> * GETIMP 获取实现</span><br><span class="line"> * LOOKUP 查找</span><br><span class="line"> *</span><br><span class="line"> * Locate the implementation for a selector in a class method cache.</span><br><span class="line"> * 在类方法缓存中找到选择器的实现。</span><br><span class="line"> *</span><br><span class="line"> * When this is used in a function that doesn&#39;t hold the runtime lock,</span><br><span class="line"> * this represents the critical section that may access dead memory.</span><br><span class="line"> * If the kernel causes one of these functions to go down the recovery</span><br><span class="line"> * path, we pretend the lookup failed by jumping the JumpMiss branch.</span><br><span class="line"> * 当它用于一个不持有运行时锁的函数时，</span><br><span class="line"> * 这表示可能访问死内存的临界段。</span><br><span class="line"> * 如果内核导致其中一个函数停止恢复路径，</span><br><span class="line"> * 我们通过跳过JumpMiss分支来假装查找失败。</span><br><span class="line"> * </span><br><span class="line"> * Takes: 寄存器代表的参数</span><br><span class="line"> *	 x1 &#x3D; selector</span><br><span class="line"> *	 x16 &#x3D; class to be searched</span><br><span class="line"> *</span><br><span class="line"> * Kills:</span><br><span class="line"> * 	 x9,x10,x11,x12, x17</span><br><span class="line"> *</span><br><span class="line"> * On exit: (found) calls or returns IMP</span><br><span class="line"> *                  with x16 &#x3D; class, x17 &#x3D; IMP</span><br><span class="line"> *          (找到)  寄存器x16 &#x3D; class, x17 &#x3D; IMP</span><br><span class="line"> *</span><br><span class="line"> *          (not found) jumps to LCacheMiss</span><br><span class="line"> *          (未找到) 跳转到 LCacheMiss</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看汇编源码，结合说明，发现缓存查找，会有三种结果，<code>CacheHit</code>缓存命中、<code>CheckMiss</code>未检测到、<code>JumpMiss</code>跳转失败。</li>
</ul>
<h5 id="CacheHit-缓存命中"><a href="#CacheHit-缓存命中" class="headerlink" title="CacheHit 缓存命中"></a>CacheHit 缓存命中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x12 &#x3D; address of cached IMP, x1 &#x3D; SEL, x16 &#x3D; isa</span><br><span class="line">.macro CacheHit</span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	TailCallCachedImp x17, x12, x1, x16	&#x2F;&#x2F; authenticate and call imp 验证并调用imp</span><br><span class="line">.elseif $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	mov	p0, p17</span><br><span class="line">	cbz	p0, 9f			&#x2F;&#x2F; don&#39;t ptrauth a nil imp</span><br><span class="line">	AuthAndResignAsIMP x0, x12, x1, x16	&#x2F;&#x2F; authenticate imp and re-sign as IMP 验证imp并重签为imp</span><br><span class="line">9:	ret				&#x2F;&#x2F; return IMP</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	&#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they</span><br><span class="line">	&#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth.</span><br><span class="line">	AuthAndResignAsIMP x17, x12, x1, x16	&#x2F;&#x2F; authenticate imp and re-sign as IMP 验证imp并重签为imp</span><br><span class="line">	ret				&#x2F;&#x2F; return imp via x17</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<ul>
<li>NORMAL模式下，验证并调用imp，<code>TailCallCachedImp</code>是一个宏。</li>
<li>GETIMP模式下，验证imp并重签为imp，返回imp。</li>
<li>LOOKUP模式下，验证imp并重签为imp，返回imp。</li>
</ul>
<h5 id="CheckMiss-未检测到"><a href="#CheckMiss-未检测到" class="headerlink" title="CheckMiss 未检测到"></a>CheckMiss 未检测到</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">	&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	cbz	p9, LGetImpMiss &#x2F;&#x2F;跳转到LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	cbz	p9, __objc_msgSend_uncached &#x2F;&#x2F;跳转到__objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	cbz	p9, __objc_msgLookup_uncached &#x2F;&#x2F;跳转到__objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>缓存未命中的时候都是直接的跳转：</p>
<ul>
<li>GETIMP模式下，跳转到 <code>LGetImpMiss</code>，就是直接返回了。</li>
<li>NORMAL模式下，跳转到 <code>__objc_msgSend_uncached</code>，通过非缓存的方式，发送消息。</li>
<li>LOOKUP模式下，跳转到 <code>__objc_msgLookup_uncached</code>，通过非缓存的方式，查找imp。</li>
</ul>
<h5 id="JumpMiss跳转失败"><a href="#JumpMiss跳转失败" class="headerlink" title="JumpMiss跳转失败"></a>JumpMiss跳转失败</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.macro JumpMiss</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	b	LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	b	__objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	b	__objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>处理基本跟 <code>CheckMiss</code> 一致</p>
<h4 id="objc-msgSend-uncached-通过非缓存的方式，发送消息"><a href="#objc-msgSend-uncached-通过非缓存的方式，发送消息" class="headerlink" title="__objc_msgSend_uncached 通过非缓存的方式，发送消息"></a>__objc_msgSend_uncached 通过非缓存的方式，发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">&#x2F;&#x2F; Out-of-band p16 is the class to search</span><br><span class="line"></span><br><span class="line">MethodTableLookup &#x2F;&#x2F;方法表查询</span><br><span class="line">TailCallFunctionPointer x17 &#x2F;&#x2F;通过指针调用方法</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p>非缓存的方式，发送消息，先进行 <code>MethodTableLookup</code> 方法表查询。</p>
<h4 id="MethodTableLookup-方法表查询"><a href="#MethodTableLookup-方法表查询" class="headerlink" title="MethodTableLookup 方法表查询"></a>MethodTableLookup 方法表查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; push frame</span><br><span class="line">	SignLR</span><br><span class="line">	stp	fp, lr, [sp, #-16]!</span><br><span class="line">	mov	fp, sp</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save parameter registers: x0..x8, q0..q7</span><br><span class="line">	sub	sp, sp, #(10*8 + 8*16)</span><br><span class="line">	stp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	stp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	stp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	stp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	str	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</span><br><span class="line">	&#x2F;&#x2F; receiver and selector already in x0 and x1</span><br><span class="line">	mov	x2, x16</span><br><span class="line">	mov	x3, #3</span><br><span class="line">	bl	_lookUpImpOrForward &#x2F;&#x2F;查找imp或者消息转发</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; IMP in x0</span><br><span class="line">	mov	x17, x0</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; restore registers and return</span><br><span class="line">	ldp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	ldp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	ldp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	ldp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	ldr	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	mov	sp, fp</span><br><span class="line">	ldp	fp, lr, [sp], #16</span><br><span class="line">	AuthenticateLR</span><br></pre></td></tr></table></figure>

<p>还是汇编宏，看的出来中间调用了一个方法<code>_lookUpImpOrForward</code>，查找imp或者消息转发。</p>
<h4 id="lookUpImpOrForward-查找imp或者消息转"><a href="#lookUpImpOrForward-查找imp或者消息转" class="headerlink" title="_lookUpImpOrForward 查找imp或者消息转"></a>_lookUpImpOrForward 查找imp或者消息转</h4><p>通过全局搜索<code>_lookUpImpOrForward</code>，发现只有调用，没有实现，什么情况？</p>
<blockquote>
<p> 汇编中调用C中的函数，函数名前加下划线“_”,也算是约定俗成，这样做的目的是为了防止符号名冲突，因为在一个程序中往往是包含汇编和C文件的，汇编用于启动部分，C文件用于应用程序，最终通过编译器实现编译，对于编译器来说，汇编和C是一视同仁的，那么就会有个问题，如果在汇编和C文件中使用了同一个名字，这是很可能出现的，毕竟汇编相当于机器码也算是稍微高级的语言，在定义子程序或函数时，也是可以用英文拼写的，而C文件中，更会习惯用英文拼写。<br>所以为了防止类似的符号名 冲突，UNIX下的C语言就规定，C语言的源代码文件中的所有全局变量和函数经过编译后，相应的符号名前面会自动的加上下划线“_”。这样做的好处，就是方便是程序开发人员，不用太小心翼翼的起名，避免了与汇编文件中的符号名的冲突。</p>
</blockquote>
<p>继续全局搜索 <code>lookUpImpOrForward</code>，找到函数实现，<code>objc-runtime-old.mm</code> 中实现的是老的方法，<code>Objective-C 2.0</code> 之后就废弃了，<code>objc-runtime-new.mm</code> 中是 <code>2.0</code>的实现。</p>
<p>先看函数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* The standard IMP lookup.</span><br><span class="line">* 标准imp查找</span><br><span class="line">*</span><br><span class="line">* Without LOOKUP_INITIALIZE: tries to avoid +initialize (but sometimes fails)</span><br><span class="line">* 如果没有 LOOKUP_INITIALIZE（查找初始化）：尝试去避免调用 +initialize 方法 （但是经常会失败，而避免不了）</span><br><span class="line">*</span><br><span class="line">* Without LOOKUP_CACHE: skips optimistic unlocked lookup (but uses cache elsewhere)</span><br><span class="line">* 如果没有 LOOKUP_CACHE （查找缓存）：跳过开放式解锁查找 （但是在其他地方使用缓存）</span><br><span class="line">*</span><br><span class="line">* Most callers should use LOOKUP_INITIALIZE and LOOKUP_CACHE</span><br><span class="line">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span><br><span class="line">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span><br><span class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </span><br><span class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span><br><span class="line">*   If you don&#39;t want forwarding at all, use LOOKUP_NIL.</span><br><span class="line">*</span><br><span class="line">* 大部分调用者应该使用 LOOKUP_INITIALIZE 和 LOOKUP_CACHE 的实例，他们是关于类与子类的实例，或者 被知道是nil。</span><br><span class="line">* 如果类是一个未初始化的元类，比一个非nil的实例更快。</span><br><span class="line">* 可能返回_objc_msgForward_impcache。</span><br><span class="line">* 提供给外部使用的imps,必须被转换成 _objc_msgForward 或者 _objc_msgForward_stret。</span><br><span class="line">* 如果你一点也不希望转发，使用 LOOKUP_NIL（查找空）。</span><br><span class="line">*</span><br><span class="line">**********************************************************************&#x2F;</span><br></pre></td></tr></table></figure>

<p>再看下实际代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line">&#123;</span><br><span class="line">    const IMP forward_imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    Class curClass;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    &#x2F;&#x2F; 乐观缓存查找</span><br><span class="line">    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123; &#x2F;&#x2F; 如果有缓存查找标记，进行缓存查找</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) goto done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; runtimeLock is held during isRealized and isInitialized checking</span><br><span class="line">    &#x2F;&#x2F; to prevent races against concurrent realization.</span><br><span class="line">    &#x2F;&#x2F; 在实现和初始化检查期间持有runtimeLock,是防止并发实现之间的竞争。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; runtimeLock is held during method search to make</span><br><span class="line">    &#x2F;&#x2F; method-lookup + cache-fill atomic with respect to method addition.</span><br><span class="line">    &#x2F;&#x2F; Otherwise, a category could be added but ignored indefinitely because</span><br><span class="line">    &#x2F;&#x2F; the cache was re-filled with the old value after the cache flush on</span><br><span class="line">    &#x2F;&#x2F; behalf of the category.</span><br><span class="line">    &#x2F;&#x2F; 在方法搜索期间保持的 runtimeLock，使 method-lookup + cache-fill保持原子性，相对于方法添加。</span><br><span class="line">    &#x2F;&#x2F; 另外，一个可以添加的类别，应该无限期地忽略它，因为类别的缓存刷新之后，缓存被重新填充为原来的旧值。</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t want people to be able to craft a binary blob that looks like</span><br><span class="line">    &#x2F;&#x2F; a class but really isn&#39;t one and do a CFI attack.</span><br><span class="line">    &#x2F;&#x2F; 我们不希望人们能够创建一个看起来像类但实际上不是类的二进制大对象，并进行CFI攻击。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; To make these harder we want to make sure this is a class that was</span><br><span class="line">    &#x2F;&#x2F; either built into the binary or legitimately registered through</span><br><span class="line">    &#x2F;&#x2F; objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.</span><br><span class="line">    &#x2F;&#x2F; 为了增加难度，我们需要确保这是一个内建在二进制文件中的类，</span><br><span class="line">    &#x2F;&#x2F; 或者是通过objc_duplicateClass、objc_initializeClassPair或objc_allocateClassPair合法注册的类。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; TODO: this check is quite costly during process startup.</span><br><span class="line">    &#x2F;&#x2F; TODO: 这种检查在进程启动期间非常昂贵。</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (slowpath(!cls-&gt;isRealized())) &#123; &#x2F;&#x2F;类是否被实现了</span><br><span class="line">        &#x2F;&#x2F;实现类，也可能是swift的类</span><br><span class="line">        cls &#x3D; realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line">        &#x2F;&#x2F; runtimeLock可能已经被删除，但现在又被锁定了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化类</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; runtimeLock may have been dropped but is now locked again</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, class_initialize will send +initialize and </span><br><span class="line">        &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">        &#x2F;&#x2F; 如果sel &#x3D;&#x3D; initialize, class_initialize将发送+initialize，</span><br><span class="line">        &#x2F;&#x2F; 然后在此过程完成后，messenger将再次发送+initialize。</span><br><span class="line">        &#x2F;&#x2F; 当然，如果这不是从messenger调用的，那么它就不会发生。2778172</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass &#x3D; cls;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The code used to lookup the class&#39;s cache again right after</span><br><span class="line">    &#x2F;&#x2F; we take the lock but for the vast majority of the cases</span><br><span class="line">    &#x2F;&#x2F; evidence shows this is a miss most of the time, hence a time loss.</span><br><span class="line">    &#x2F;&#x2F; 在锁定之后，用于再次查找类缓存的代码，但是对于绝大多数情况，</span><br><span class="line">    &#x2F;&#x2F; 有证据表明这在大多数情况下是错误的，因此是时间损失。</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; The only codepath calling into this without having performed some</span><br><span class="line">    &#x2F;&#x2F; kind of cache lookup is class_getInstanceMethod().</span><br><span class="line">    &#x2F;&#x2F; 惟一调用它而没有执行某种缓存查找的代码路径是class_getInstanceMethod()。</span><br><span class="line"></span><br><span class="line">    for (unsigned attempts &#x3D; unreasonableClassCount();;) &#123;&#x2F;&#x2F;一个防止循环自旋的数</span><br><span class="line">        &#x2F;&#x2F; curClass method list.</span><br><span class="line">        &#x2F;&#x2F; 从当前类的方法列表查找。</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123; &#x2F;&#x2F;找到直接返回</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (slowpath((curClass &#x3D; curClass-&gt;superclass) &#x3D;&#x3D; nil)) &#123;</span><br><span class="line">            &#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help.</span><br><span class="line">            &#x2F;&#x2F; Use forwarding.</span><br><span class="line">            &#x2F;&#x2F; 没有找到方法，而且方法解析器没有作用，进行方法转发</span><br><span class="line">            imp &#x3D; forward_imp;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">        &#x2F;&#x2F; 如果超类链中有一个循环，则停止</span><br><span class="line">        if (slowpath(--attempts &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass cache.</span><br><span class="line">        &#x2F;&#x2F; 从父类的缓存查找</span><br><span class="line">        imp &#x3D; cache_getImp(curClass, sel);&#x2F;&#x2F;这是个汇编方法，内部调用CacheLookUp</span><br><span class="line">        if (slowpath(imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">            &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method</span><br><span class="line">            &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fastpath(imp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line">    &#x2F;&#x2F; 没有找到方法，尝试方法解析器</span><br><span class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^&#x3D; LOOKUP_RESOLVER;</span><br><span class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);&#x2F;&#x2F;找到后，标记和放到缓存。</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有 <code>LOOKUP_CACHE</code> 标记，进行缓存查找。</li>
<li>检测是否是已知的类</li>
<li>判断类是否已经实现，如果没实现，实现类（也有肯是swift的类）</li>
<li>如果有 <code>LOOKUP_INITIALIZE</code> 标记，判断是否已经初始化。<ul>
<li>如果没有初始化，进行类初始化，这时，会调用类的 <code>+initialize</code>方法。</li>
</ul>
</li>
<li>进行方法的循环查找。<ul>
<li>从类的方法列表中查找。<ul>
<li>如果找到，跳转到 <code>done</code>。</li>
</ul>
</li>
<li>未找到，<code>curClass</code> 指向 父类。<ul>
<li>如果父类是nil，说明查找失败，进行消息转发，并跳出循环。</li>
</ul>
</li>
<li>从父类的缓存中查找。</li>
<li>如果 方法 == <code>forward_imp</code>， 跳出循环。</li>
<li>如果找到，跳转到 <code>done</code>。</li>
</ul>
</li>
<li>如果有 <code>LOOKUP_RESOLVER</code>, 返回 方法解析。</li>
<li><code>done</code> <ul>
<li>标记方法并放到缓存。</li>
</ul>
</li>
<li><code>done_nolock</code><ul>
<li>如果有 <code>LOOKUP_NIL</code> 标记，并且 方法 == <code>forward_imp</code>，返回 nil。</li>
</ul>
</li>
<li>返回方法imp。</li>
</ul>
<p>上面是整个方法查找流程，先找缓存，再找方法列表，然后去父类的缓存查找，再次是父类的方法列表，知道父类是nil，查找失败，触发消息转发。<br>首次查找的时候，会有 <code>LOOKUP_RESOLVER</code>标记，找不到的时候，会触发 <code>resolveMethod_locked</code>方法解析，整个函数会调用类的 <code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，然后再进行一次方法查找 <code>lookUpImpOrForward</code>，这次就没有 <code>LOOKUP_RESOLVER</code>标记了。</p>
<h4 id="objc-msgForward-方法转发"><a href="#objc-msgForward-方法转发" class="headerlink" title="_objc_msgForward 方法转发"></a>_objc_msgForward 方法转发</h4><ul>
<li>当方法查找失败的时候，触发消息转发 <code>_objc_msgForward_impcache</code>，而 <code>_objc_msgForward_impcache</code> 内部汇编实现，直接调用的 <code>__objc_msgForward</code>。</li>
<li><code>__objc_msgForward</code> 内部实现，调用了 <code>__objc_forward_handler</code>。</li>
</ul>
<h4 id="objc-forward-handler-方法转发句柄"><a href="#objc-forward-handler-方法转发句柄" class="headerlink" title="_objc_forward_handler 方法转发句柄"></a>_objc_forward_handler 方法转发句柄</h4><p>这是一个函数指针，根据宏定义，有不同的实现，研究版本是 <code>Objective-C 2.0</code>，所以是 <code>__OBJC2__</code> 对应的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#if !__OBJC2__</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default forward handler (nil) goes to forward:: dispatch.</span><br><span class="line">void *_objc_forward_handler &#x3D; nil;</span><br><span class="line">void *_objc_forward_stret_handler &#x3D; nil;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Default forward handler halts the process.</span><br><span class="line">__attribute__((noreturn, cold)) void</span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler &#x3D; (void*)objc_defaultForwardHandler;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_STRET</span><br><span class="line">struct stret &#123; int i[100]; &#125;;</span><br><span class="line">__attribute__((noreturn, cold)) struct stret</span><br><span class="line">objc_defaultForwardStretHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    objc_defaultForwardHandler(self, sel);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_stret_handler &#x3D; (void*)objc_defaultForwardStretHandler;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><code>void *_objc_forward_handler = (void*)objc_defaultForwardHandler</code>，表示最后的实现是 <code>objc_defaultForwardHandler</code>，在里面我们看到了熟悉的 <code>unrecognized selector sent to instance</code> 未定义的错误打印。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<p>精简步骤为：</p>
<ol>
<li>空指针检测</li>
<li>缓存快速查找</li>
<li>非缓存的慢速查找（方法列表查询）<ol>
<li>检测类实现</li>
<li>检测类初始化</li>
<li>从当前类的方法列表查找，找打跳转到<code>10</code>，未找到跳转<code>4</code></li>
<li>将当前类指向父类，如果父类为空，imp = forward_imp，跳转到<code>7</code>，不为空，跳转<code>5</code></li>
<li>查找父类的缓存，找打跳转到<code>10</code>，未找到跳转<code>6</code></li>
<li>跳转到3</li>
<li>查找结束</li>
<li>检测LOOKUP_RESOLVER，有，跳转到<code>9</code>，没有跳转到<code>10</code></li>
<li>方法解析<ol>
<li>是否元类，是跳转到2，不是跳转到<code>4</code></li>
<li>调用<code>+resolveClassMethod</code></li>
<li>快速缓存查找，找到跳转到<code>5</code>，未找到跳转到<code>4</code></li>
<li>调用<code>+resolveInstanceMethod</code></li>
<li>带有缓存标记的普通查找。</li>
</ol>
</li>
<li>标记并缓存imp</li>
<li>返回imp</li>
</ol>
</li>
<li>imp是普通imp，直接调用。</li>
<li>imp是forward_imp，实际实现是<code>_objc_forward_handler</code>，指向的是<code>objc_defaultForwardHandler</code>，打印消息，并抛出异常。</li>
</ol>
<blockquote>
<p>从上面的步骤看出，当方法未找到时，源码中只触发了，消息转发的第一步，<strong>动态解析</strong>，即<code>+resolveClassMethod</code>、<code>+resolveInstanceMethod</code>，并没有后续的，<strong>快速转发</strong>，以及<strong>普通转发阶段</strong>，大概是在<code>Foundation</code>中做了，<code>_objc_forward_handler</code>是一个函数指针，后续是可以被赋值改变的。</p>
</blockquote>

            </div>
        </article>
    
</div>
<div class="side-bar">


    <div class="avator" id="avator">
    <div class="title">
        <a href="#" class="text-underline">About Me</a>
    </div>
        <img src="images/zhrmghgfff.jpeg" class="ava-img">
        <h3 class="author">zhrmghgfff</h3>
        <div class="icon-list">
        <a href="yourweibo"><i class="iconfont icon-weibo icon-item"></i></a>
        <a href="mailto:youremail"><i class="iconfont icon-email icon-item"></i></a>
        <a href="yourgithub"><i class="iconfont icon-github icon-item"></i></a>
        <a href="yourlinkedin"><i class="iconfont icon-linkedin icon-item"></i></a>
        </div>
    <div class="tags">
    <h3 class="tags-title">Tags</h3>
    
</div>
    </div>
</div>

</section>



            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> | Theme <a href="https://github.com/zjx137/hexo-theme-Tsu" target="_blank" rel="noopener">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
