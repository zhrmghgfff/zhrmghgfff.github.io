<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<link rel="stylesheet" href="/styles/main.css">

    <meta name="generator" content="Hexo 4.2.1"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">M的博客</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about/">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
<div class="post-wrapper">
    <article class="post article-entry">
    <div class="post-title">
        Swift 一步步解决回调地狱
    </div>
    <p class="sub">Jun 09 2020</p>
    <div class="post-content">
        <h1 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h1><p>回调地狱，是多线程任务中，经常会遇到的问题，任务中经常有这样的需求，任务2要依赖任务1，必须在任务1完成之后再执行，最普通的做法就是 <code>GCD</code> 异步执行，完成后，开始下一个任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    sleep(1)</span><br><span class="line"></span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        &#x2F;&#x2F;任务2</span><br><span class="line">        sleep(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是连续性<code>3</code>个任务，或<code>4</code>个任务，或<code>n</code>个任务，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    sleep(1)</span><br><span class="line"></span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        &#x2F;&#x2F;任务2</span><br><span class="line">        sleep(1)</span><br><span class="line"></span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            &#x2F;&#x2F;任务3</span><br><span class="line">            sleep(1)</span><br><span class="line"></span><br><span class="line">            DispatchQueue.global().async &#123;</span><br><span class="line">                &#x2F;&#x2F;任务4</span><br><span class="line">                sleep(1)</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了熟悉的回调地狱，谁都不希望写这样的代码，可读性太差了。调试起来也是灾难。</p>
<blockquote>
<p>可能有人会说，为什么不使用，串行队列，多方便，但是串行队列，添加完的任务，是没办法取消的，或者取消起来很麻烦，再者，一般这种任务依赖都是数据上的有依赖的，使用串行队列，数据传递也是问题。</p>
</blockquote>
<h1 id="回调地狱的思考"><a href="#回调地狱的思考" class="headerlink" title="回调地狱的思考"></a>回调地狱的思考</h1><p>现实的任务，例如网络任务，都是有自己的回调的，一般都是封装成是一个函数，回调是一个<code>block</code>，作为参数传进去。但是如果任务有顺序依赖，还是会有回调地狱存在。<br>怎么才能改善这种情况呢？</p>
<h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p>链式编程可以把对同一个实例对象同时调用N次方法。代码的可读性更好。 比较有名的第三方库：<code>OC</code> 的 <code>Masonry</code>、<code>Swift</code> 的 <code>SnapKit</code>。</p>
<p><strong>普通的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;未处理代码</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    self.method1()</span><br><span class="line">    self.method2()</span><br><span class="line">    self.method3()</span><br><span class="line">    self.method4()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method1() &#123;</span><br><span class="line">    print(&quot;method1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method2() &#123;</span><br><span class="line">    print(&quot;method2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method3() &#123;</span><br><span class="line">    print(&quot;method3&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method4() &#123;</span><br><span class="line">    print(&quot;method4&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链式代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 链式处理后代码</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    _ &#x3D; self.method1().method2().method3().method4()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method1() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method1&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method2() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method2&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method3() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method3&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func method4() -&gt; LineViewController &#123;</span><br><span class="line">    print(&quot;method4&quot;)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改的思路"><a href="#修改的思路" class="headerlink" title="修改的思路"></a>修改的思路</h2><p>链式编程的写法，特别适合用来改造，回调地狱，理想的任务依赖，通过链式的调用，非常合适，看起来，就知道后一个任务依赖前一个任务。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; </span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    sleep(1)</span><br><span class="line">&#125;</span><br><span class="line">.task&#123; </span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    sleep(1)</span><br><span class="line">&#125;</span><br><span class="line">.task&#123; </span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    sleep(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务就是<code>block</code>，<code>block</code>有两个优点：</p>
<ul>
<li>可以存储、传递。</li>
<li>可以灵活的实现任务。</li>
</ul>
<blockquote>
<p>按照上面设想，我们来一步一步实现。</p>
</blockquote>
<h1 id="MyGCD-1-0"><a href="#MyGCD-1-0" class="headerlink" title="MyGCD 1.0"></a>MyGCD 1.0</h1><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>链式编程精髓就是<strong>返回对象自己</strong>，后续就可以进行正常调用，依次再次调用函数，就形成了链式调用。<br>那么初始版本的 <code>MyGCD</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    typealias Task &#x3D; () -&gt; Void</span><br><span class="line"></span><br><span class="line">    func task(task: Task) -&gt; MyGCD &#123;</span><br><span class="line">        task()</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的写法，会有警告<code>Result of call to &#39;task(task:)&#39; is unused</code>，就是返回值没有使用，在函数定义的时候加上<code>@discardableResult</code>，让编译器不用提示这个警告。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func task(task: Task) -&gt; MyGCD &#123;</span><br><span class="line">    task()</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    print(&quot;任务1&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    print(&quot;任务2&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    print(&quot;任务3&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">任务1</span><br><span class="line">任务2</span><br><span class="line">任务3</span><br><span class="line">发布任务完毕</span><br></pre></td></tr></table></figure>

<p>链式调用成功，但是任务还没添加异步和耗时呢，现在我们添加一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务1 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务1 结束&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务2 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务2 结束&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务3 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务3 结束&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">任务1 开始</span><br><span class="line">发布任务完毕</span><br><span class="line">任务3 开始</span><br><span class="line">任务2 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 结束</span><br></pre></td></tr></table></figure>

<p>全乱了，异步执行之后，都是子线程执行，开始和结束都是随机的，再次运行一次，结果还会不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">任务2 开始</span><br><span class="line">任务3 开始</span><br><span class="line">任务1 开始</span><br><span class="line">发布任务完毕</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 结束</span><br><span class="line">任务1 结束</span><br></pre></td></tr></table></figure>

<p>怎么办呢？</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>多线程同步的一般会使用信号量 <code>DispatchSemaphore</code>，信号量内部维护一个 <code>value</code>，信号量的核心就在于对 <code>value</code>的增减。</p>
<ul>
<li>init(value: Int) 以一个数初始化信号量</li>
<li>wait() 等待，当信号量的 <code>value</code> 大于等于1时，返回，并 <code>value</code> - 1</li>
<li>signal() 发送信号，信号量的 <code>value</code> + 1</li>
</ul>
<p>现在使用信号量改造一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;任务1</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务1 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务1 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;.task &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;任务2</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务2 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务2 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;.task &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;任务3</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;任务3 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;任务3 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">发布任务完毕</span><br></pre></td></tr></table></figure>

<p>任务按顺序执行了，但是<code>发布任务完毕</code>跑到了最后，因为<code>semaphore.wait()</code>会阻塞当前线程，那么怎么不阻塞当前线程呢？<strong>答案是</strong>：使任务所在的<code>block</code>，在子线程异步执行。修改代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修改MyGCD的task方法</span><br><span class="line">@discardableResult</span><br><span class="line">func task(task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        task()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了看到主线程是否被阻塞，在每个任务的异步前增加打印，因为我们的任务结构相似，我们封装一个方法，方便我们调试，并且精简下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func createTask(_ desc: String) &#123;</span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line"></span><br><span class="line">    print(&quot;\(desc) 发布&quot;)</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;\(desc) 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;\(desc) 结束&quot;)</span><br><span class="line"></span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semaphore.wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的任务代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123;</span><br><span class="line">    createTask(&quot;任务1&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    createTask(&quot;任务2&quot;)</span><br><span class="line">&#125;.task &#123;</span><br><span class="line">    createTask(&quot;任务3&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>运行，输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发布任务完毕</span><br><span class="line">任务2 发布</span><br><span class="line">任务1 发布</span><br><span class="line">任务3 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务1 开始</span><br><span class="line">任务3 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务3 结束</span><br><span class="line">任务2 结束</span><br></pre></td></tr></table></figure>

<p>发现没有阻塞当前线程，但是任务又乱了…， 而且任务的发布也是乱的，按照我们的设想，任务的发布也应该是顺序的。</p>
<h2 id="还是信号量"><a href="#还是信号量" class="headerlink" title="还是信号量"></a>还是信号量</h2><p>保证任务的发布，也是需要信号量来控制任务<code>block</code>的执行，修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func task(task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let semaphore &#x3D; DispatchSemaphore(value: 0)</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        task()</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">    semaphore.wait()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">发布任务完毕</span><br></pre></td></tr></table></figure>

<p>所有的执行都顺序，执行了，但是老问题又来了，阻塞当前线程了，用信号量将所有的任务串了起来，效果等同于同步执行，但是我们一般都希望，任务是异步执行的，不用阻塞当前线程，那么创建任务的方式需要修改，改成我们正常的任务实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func createTask(_ desc: String, complete:() -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">    print(&quot;\(desc) 发布&quot;)</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        print(&quot;\(desc) 开始&quot;)</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;\(desc) 结束&quot;)</span><br><span class="line"></span><br><span class="line">        complete()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回归现实"><a href="#回归现实" class="headerlink" title="回归现实"></a>回归现实</h2><p>正常的任务，异步执行，完成之后有一个回调，那么我们的 <code>MyGCD</code> 怎么知道任务回调回来了呢，也就是 <code>任务的完成</code> ？现在的方式，没有地方接受，以及处理<code>任务的完成</code>。那么整理一下<code>MyGCD</code>的功能：</p>
<ol>
<li>将任务传递进去</li>
<li>合适的时机执行任务</li>
<li>任务执行完成之后，通知我们任务执行完成</li>
<li>通知后续的任务执行</li>
</ol>
<p>第<code>1</code>步：参数是 <code>block</code> 即可满足要求。<br>第<code>2</code>步：合适的时机，一般我们创建任务的时候都希望，立即执行。<br>第<code>3</code>步：返回来通知任务完成，那么我们需要将对象传递进任务中，也即是<code>block</code>中，那么<code>block</code> 就需要一个参数 <code>MyGCD</code>。<br>第<code>4</code>步：后续任务，需要单独一个方法来处理，并且只能先存起来，等待当前任务完成后，才能开始任务。</p>
<p>结合上面的几点，其实不需要信号量了，我们需要暴露一个方法，来处理 <code>任务的完成</code>，现在对 <code>MyGCD</code> 进行改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class MyGCD &#123;</span><br><span class="line">    typealias Task &#x3D; (MyGCD) -&gt; Void</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务完成后执行的方法</span><br><span class="line">    fileprivate var complete : Task?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: block 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">    @discardableResult</span><br><span class="line">    func task(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">        startTask(action)</span><br><span class="line"></span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 设置完成的回调</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter action: block 任务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">    @discardableResult</span><br><span class="line">    func onComplete(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">        complete &#x3D; action</span><br><span class="line"></span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务完成</span><br><span class="line">    func taskDone() &#123;</span><br><span class="line">        if let complete &#x3D; complete &#123;</span><br><span class="line">            complete(self)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; MARK: 私有函数</span><br><span class="line">    fileprivate func startTask(_ task:@escaping Task) &#123;</span><br><span class="line"></span><br><span class="line">        var gcd:MyGCD? &#x3D; self</span><br><span class="line"></span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line"></span><br><span class="line">            task(gcd!)</span><br><span class="line"></span><br><span class="line">            gcd &#x3D; nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有个小技巧，<code>MyGCD</code> 生成的对象是一个局部对象，在<code>任务发布完成</code>后，生命周期就应该结束了，而<code>任务block</code>中，需要传入这个对象，如果传入的是<code>strong</code>的对象，那么就会形成<code>循环引用</code>，导致 <code>MyGCD</code> 对象无法释放，如果传入的是<code>weak</code>的对象，因为他的生命周期问题，直接就被释放了，导致<code>任务block</code>中，传入的 <code>MyGCD</code> 对象为 <code>nil</code> 。<br>解除循环引用的一个小技巧，在<code>block</code>强引用捕获对象的时候，在适当的时机，将捕获的对象在 <code>block</code> 中释放掉，就可以解除循环引用，简单的操作就是，将变量赋值成 <code>nil</code>，被引用的对象就减少了一个引用，就可以被释放掉了。</p>
</blockquote>
<ul>
<li>新增 <code>onComplete</code> 方法，设置任务完成后的回调，就是下一个任务。</li>
<li>新增 <code>taskDone</code> 方法，任务完成。在任务 <code>block</code> 中，完成任务后，需要调用此方法。</li>
</ul>
<p>最后是运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.taskDone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.onComplete&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.taskDone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.onComplete &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.taskDone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">发布任务完毕</span><br><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>出现了两个问题：</p>
<ul>
<li><code>任务1</code> 之后是 <code>任务3</code>，不是 <code>任务2</code>，顺序不对。</li>
<li><code>任务3</code> 一直循环，不结束。</li>
</ul>
<p>对于顺序问题，因为我们返回的都是同一个 <code>MyGCD</code>对象，所以后调用的 <code>onComplete</code>，会覆盖前一个的调用，因为 <code>onComplete</code> 中传入的下一个任务，所以应该返回一个新的<code>MyGCD</code>对象，那么修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func onComplete(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有个问题，实际的任务 <code>action</code>，是在其他地方调用的，而 <code>newGCD</code> 是个局部变量，拿不到怎么办？<br>其实我们有一个很好的方法来解决他，那就是 <code>block</code>，没错，就是 <code>block</code>, 使用 <code>block</code> 可以捕获变量的特性，来传递对象。那么就可以这样修改，在 <code>MyGCD</code> 中声明一个 <code>block</code> 属性，然后对他进行赋值，来传递 <code>newGCD</code>。</p>
<p>生命一个 <code>completeAction</code> 属性，进行赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func onComplete(_ action:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line"></span><br><span class="line">    completeAction &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">        action(newGCD)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务完成后，执行 <code>completeAction</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func taskDone() &#123;</span><br><span class="line">    if let completeAction &#x3D; completeAction &#123;</span><br><span class="line">        completeAction()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发布任务完毕</span><br><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br></pre></td></tr></table></figure>

<p>结果完美。</p>
<p>但是还需要验证一下，创建的临时 <code>MyGCD</code> 对象，有没有被释放，给 <code>MyGCD</code> 添加 <code>init</code> 和 <code>deinit</code> 方法，再增加一个 <code>tag</code> 属性，来区分各个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;记录总创建的个数</span><br><span class="line">fileprivate static var count:Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 标记，区分每个不同的对象</span><br><span class="line">fileprivate var tag: Int</span><br><span class="line"></span><br><span class="line">init() &#123;</span><br><span class="line"></span><br><span class="line">    tag &#x3D; MyGCD.count</span><br><span class="line"></span><br><span class="line">    print(&quot;init : \(tag)&quot;)</span><br><span class="line"></span><br><span class="line">    MyGCD.count +&#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deinit &#123;</span><br><span class="line">    print(&quot;deinit : \(tag)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来运行下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">init : 1</span><br><span class="line">init : 2</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 发布</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务2 发布</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务3 发布</span><br><span class="line">deinit : 1</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">deinit : 2</span><br></pre></td></tr></table></figure>

<p>3个任务，创建了 <code>MyGCD</code> 三个对象，执行完任务后，对象被释放，任务顺序也跟预想的一致，而且 <code>MyGCD</code> 对象的创建以及释放顺序，也跟任务的顺序一致。</p>
<h2 id="1-0-大功告成"><a href="#1-0-大功告成" class="headerlink" title="1.0 大功告成"></a>1.0 大功告成</h2><h1 id="MyGCD-2-0"><a href="#MyGCD-2-0" class="headerlink" title="MyGCD 2.0"></a>MyGCD 2.0</h1><p><code>1.0</code>完成了，证明<code>回调地狱</code>也不是什么难题吗，我们完全可以解决。<br>但是，现实的任务，没有那么简单，任务执行的过程中，会有各种各样的麻烦、状况，或者说异常出现，例如网路任务：</p>
<ul>
<li><p>正常返回</p>
</li>
<li><p>请求超时</p>
</li>
<li><p>请求参数错误</p>
</li>
<li><p>服务器出异常，无法访问</p>
</li>
<li><p>网络异常，无法发起请求</p>
</li>
<li><p>…等等问题</p>
<p><code>1.0</code> 只能处理正常返回的情况，其他的异常情况，不能处理，而现实中的任务依赖，一旦任务出现异常，那么后续的任务就没有继续执行的意思了，而且异常发生了，我们需要对异常进行处理，那么就需要对我们的<code>MyGCD</code>，进行再次的修改。</p>
</li>
</ul>
<h2 id="增加next"><a href="#增加next" class="headerlink" title="增加next"></a>增加<code>next</code></h2><p>之前的<code>onComplete</code>有个问题，那就是命名，其实应该是下一个任务，并且使用方式也不对，应该将 <code>block</code> 任务放到 <code>newGCD</code> 中，所以现在将方法名字修改掉，改为 <code>next</code>，那么对应 <code>complete</code>属性，也就不需要了，我们需要的是一个新的成员变量，来保存<code>newGCD</code>，并且还需要一个属性，来保存下一个 <code>block</code> 任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 下一个 MyGCD</span><br><span class="line">fileprivate var nextGCD : MyGCD?</span><br><span class="line">&#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">fileprivate var task : Task?</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 下一个任务</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Parameter action: block 任务</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">@discardableResult</span><br><span class="line">func next(_ task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line">    newGCD.task &#x3D; task</span><br><span class="line">    nextGCD &#x3D; newGCD</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加-State"><a href="#增加-State" class="headerlink" title="增加 State"></a>增加 <code>State</code></h2><p>现在任务结束需要一些状态，<code>完成</code>、<code>错误</code>以及<code>取消</code>，当任务链中的有错误发生时，后续的任务就需要取消了，需要定义一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 任务结束时的状态</span><br><span class="line">enum State &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    case complete(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    case error(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取消</span><br><span class="line">    case cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于返回的结果，暂时定义 <code>code</code>、<code>message</code>、<code>data</code> 三个属性，如果有需要，可以再自定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 结果</span><br><span class="line">struct Result &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 状态码</span><br><span class="line">    var code: Int</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 信息</span><br><span class="line">    var message: String</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 数据</span><br><span class="line">    var data: Any?</span><br><span class="line"></span><br><span class="line">    init(_ code: Int,_ message: String &#x3D; &quot;&quot;,_ data: Any? &#x3D; nil) &#123;</span><br><span class="line">        self.code &#x3D; code</span><br><span class="line">        self.message &#x3D; message</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加-error"><a href="#增加-error" class="headerlink" title="增加 error"></a>增加 <code>error</code></h2><p>现在状态有了，那么就需要增加对错误的处理了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typealias ResultAction &#x3D; (Result) -&gt; Void</span><br><span class="line">&#x2F;&#x2F;&#x2F; 错误处理</span><br><span class="line">fileprivate var error : ResultAction?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 错误处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Parameter action: block 处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">@discardableResult</span><br><span class="line">func error(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    error &#x3D; action</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加complete"><a href="#增加complete" class="headerlink" title="增加complete"></a>增加<code>complete</code></h2><p>既然有任务的错误，那么对应的就有任务的完成处理，而<code>next</code>专职于下一个任务，增加<code>complete</code>处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 完成处理</span><br><span class="line">fileprivate var complete : ResultAction?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 完成处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Parameter action: block 处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Returns: MyGCD</span><br><span class="line">@discardableResult</span><br><span class="line">func complete(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改endAction"><a href="#修改endAction" class="headerlink" title="修改endAction"></a>修改<code>endAction</code></h2><p>原来的 <code>completeAction</code> 只是简单的执行下 <code>complete</code>，现在需要处理结束后不同的状态，名字改为 <code>endAction</code> 更为合适一些，而且，只有当 <code>next</code>、<code>complete</code> 或者 <code>error</code> 处理添加的时候，才需要添加，其他情况并不需要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typealias EndAction &#x3D; (State) -&gt; Void</span><br><span class="line">&#x2F;&#x2F;&#x2F; 任务结束处理</span><br><span class="line">fileprivate var endAction : EndAction?</span><br><span class="line">&#x2F;&#x2F;&#x2F; 任务完成</span><br><span class="line">func end(_ state: State) &#123;</span><br><span class="line">    if let endAction &#x3D; endAction &#123;</span><br><span class="line">        endAction(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 创建endAction</span><br><span class="line">fileprivate func createEndAction() &#123;</span><br><span class="line"></span><br><span class="line">    if endAction !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var gcd:MyGCD? &#x3D; self</span><br><span class="line"></span><br><span class="line">    endAction &#x3D; &#123; (state) in</span><br><span class="line"></span><br><span class="line">        switch state &#123;</span><br><span class="line">            case .complete(let result):</span><br><span class="line"></span><br><span class="line">                if let complete &#x3D; gcd?.complete &#123;</span><br><span class="line">                    complete(result)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if let nextGCD &#x3D; gcd?.nextGCD, let task &#x3D; nextGCD.task &#123;</span><br><span class="line">                        nextGCD.startTask(task)</span><br><span class="line">                    &#125;</span><br><span class="line">            case .error(let result):</span><br><span class="line">                if let error &#x3D; gcd?.error  &#123;</span><br><span class="line">                    error(result)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                gcd?.nextGCD?.end(.cancel)</span><br><span class="line">            case .cancel:</span><br><span class="line">                gcd?.nextGCD?.end(.cancel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gcd?.nextGCD &#x3D; nil</span><br><span class="line">        gcd &#x3D; nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否创建，防止重复创建、</li>
<li><code>complete</code> ： 执行 <code>complete</code> 处理，执行下一个任务</li>
<li><code>error</code> ： 执行 <code>error</code> 处理，取消下一个任务</li>
<li><code>cancel</code> ： 取消下一个任务 （相当于链式取消后面的所有任务）</li>
<li>清理强引用，解除引用循环，以便当前 <code>MyGCD</code> 对象释放</li>
</ul>
<p>将 <code>createEndAction()</code> 添加到 <code>complete</code>、<code>error</code>方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func next(_ task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line">    newGCD.task &#x3D; task</span><br><span class="line">    nextGCD &#x3D; newGCD</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func complete(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    complete &#x3D; action</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func error(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    error &#x3D; action</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在开始测试，给每个任务，添加 <code>complete</code> 以及 <code>error</code> 处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.complete(MyGCD.Result(200)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务1 错误: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.complete(MyGCD.Result(200)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务2 错误: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.complete(MyGCD.Result(200)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务3 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">任务1 发布</span><br><span class="line">init : 1</span><br><span class="line">init : 2</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 开始</span><br><span class="line">任务1 结束</span><br><span class="line">任务1 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务2 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 1</span><br><span class="line">任务3 发布</span><br><span class="line">任务3 开始</span><br><span class="line">任务3 结束</span><br><span class="line">任务3 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们发现测试代码，写的很啰嗦，特别是 <code>Result</code> 的创建，需要写一大串，非常的不美观，现在我们对<code>Result</code>进行一下扩展，来简化我们的代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension MyGCD.Result &#123;</span><br><span class="line">    static var success: MyGCD.Result &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Result(200)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func result(_ code: Int,_ message: String &#x3D; &quot;&quot;,_ data: Any? &#x3D; nil) -&gt; MyGCD.Result &#123;</span><br><span class="line">        return Result(code,message,data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>gcd.end(.complete(MyGCD.Result(200)))</code> -&gt; <code>gcd.end(.mplete(success))</code>，感觉还是有点啰嗦，而且 <code>complete</code> 和 <code>error</code> 侧重的数据是不一样的，我们可以对<code>State</code> 进行扩展。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension MyGCD.State &#123;</span><br><span class="line">    static func sucess(_ data:Any? &#x3D; nil) -&gt; MyGCD.State &#123;</span><br><span class="line">        return .complete(.result(200, nil, data))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func error(_ code: Int,_ message: String? &#x3D; nil,_ data: Any? &#x3D; nil) -&gt; MyGCD.State &#123;</span><br><span class="line">        return .error(.result(code, message, data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改测试代码，将其中一个任务，返回错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务1 错误: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.error(404))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务2 错误: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务3 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p><code>任务2</code> 返回错误后，后续的<code>任务3</code>并没有执行，并且 <code>MyGCD</code> 的所有对象都释放了。（可以验证，<code>任务1</code>返回错误后，后续的任务也可正常取消掉）。</p>
<h2 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h2><p>实际情况下，系列任务中，只要有一个任务失败了，所有任务都需要重头再来，或者干些其他操作，基本的处理都差不多一样，那么给每一个任务都添加一样的错误处理，太不优雅了，如果能在最后一个任务那里，添加错误处理，前面的所有的任务，都进行同样的错误处理，就好了。</p>
<p>因为是从后向前传递 <code>error</code> 处理，那么 <code>MyGCD</code> 需要一个回调，当 <code>error</code> 处理赋值的时候，通知前一个任务。那么创建下一个 <code>MyGCD</code> 的时候，我们需要封装一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typealias ErrorCallback &#x3D; (@escaping ResultAction) -&gt; Void</span><br><span class="line">&#x2F;&#x2F;&#x2F; 错误处理已经添加的回调</span><br><span class="line">fileprivate var errorDidAdded : ErrorCallback?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 创建NextGCD</span><br><span class="line">func createNextGCD(_ task: @escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    let newGCD &#x3D; MyGCD()</span><br><span class="line">    newGCD.errorDidAdded &#x3D; &#123;[weak self] action in</span><br><span class="line">        if self?.error &#x3D;&#x3D; nil &#123;</span><br><span class="line">            self?.error(action)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            self?.transmitError(action)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newGCD.task &#x3D; task</span><br><span class="line"></span><br><span class="line">    return newGCD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 传递Error处理</span><br><span class="line">func transmitError(_ action:@escaping ResultAction) &#123;</span><br><span class="line"></span><br><span class="line">    if let errorDidAdded &#x3D; errorDidAdded &#123;</span><br><span class="line">        errorDidAdded(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>next</code> 、 <code>error</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func next(_ task:@escaping Task) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    nextGCD &#x3D; createNextGCD(task)</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return nextGCD!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func error(_ action:@escaping ResultAction) -&gt; MyGCD &#123;</span><br><span class="line"></span><br><span class="line">    error &#x3D; action</span><br><span class="line">    transmitError(action)</span><br><span class="line">    createEndAction()</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改下测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.error(404))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务有 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">任务1 发布</span><br><span class="line">init : 1</span><br><span class="line">init : 2</span><br><span class="line">任务1 开始</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 结束</span><br><span class="line">任务1 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务有 错误: Result(code: 404, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 2</span><br><span class="line">deinit : 1</span><br></pre></td></tr></table></figure>

<p>错误代码正常执行了，后续任务也正常取消了，<code>error</code>传递成功。</p>
<p>下面给 <code>任务2</code> 添加 <code>error</code> 处理，看下执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyGCD().task &#123; gcd in</span><br><span class="line">    createTask(&quot;任务1&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务1 complete: \(result)&quot;)</span><br><span class="line">&#125;.next&#123; gcd in</span><br><span class="line">    createTask(&quot;任务2&quot;) &#123;</span><br><span class="line">        gcd.end(.error(404))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务2 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务2 错误: \(result)&quot;)</span><br><span class="line">&#125;.next &#123; gcd in</span><br><span class="line">    createTask(&quot;任务3&quot;) &#123;</span><br><span class="line">        gcd.end(.sucess())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.complete&#123; (result) in</span><br><span class="line">    print(&quot;任务3 complete: \(result)&quot;)</span><br><span class="line">&#125;.error&#123; (result) in</span><br><span class="line">    print(&quot;任务有 错误: \(result)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;发布任务完毕&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init : 0</span><br><span class="line">任务1 发布</span><br><span class="line">init : 1</span><br><span class="line">任务1 开始</span><br><span class="line">init : 2</span><br><span class="line">发布任务完毕</span><br><span class="line">任务1 结束</span><br><span class="line">任务1 complete: Result(code: 200, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 0</span><br><span class="line">任务2 发布</span><br><span class="line">任务2 开始</span><br><span class="line">任务2 结束</span><br><span class="line">任务2 错误: Result(code: 404, message: &quot;&quot;, data: nil)</span><br><span class="line">deinit : 2</span><br><span class="line">deinit : 1</span><br></pre></td></tr></table></figure>

<p>正常设置的 <code>error</code> 处理正常执行了，并没有被覆盖。</p>
<h2 id="2-0-完成"><a href="#2-0-完成" class="headerlink" title="2.0 完成"></a>2.0 完成</h2><p>至此 2.0 的功能完成。</p>
<h1 id="MyGCD-3-0"><a href="#MyGCD-3-0" class="headerlink" title="MyGCD 3.0"></a>MyGCD 3.0</h1><p>在日常的开发中，除了顺序执行任务，还有并发执行任务，例如下载图片，肯定是同时开始下载，所有的图片都下载完成，才能算任务结束。<code>2.0</code> 版本解决不了，批量问题，那么再来改造吧。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>首先，我们先思考下，我们的功能预期，然后才能一步一步向目标迈进，设计整个处理流程。<br>现在，我们假设一下功能预期：</p>
<ol>
<li>任务并发执行</li>
<li>所有任务完成后，回调</li>
<li>可以和前面的单任务一样，进行链式调用</li>
<li>假定并发任务中，一个任务的失败，不算整组任务的失败，（就像下载图片，允许下载失败）</li>
</ol>
<blockquote>
<p>并发执行的任务，按照前面的处理，任务都是放到GCD中执行的，因为GCD不能取消，所以即使有任务失败的也不能取消其他的任务，所以对于错误处理，只是调用回调，并不算整组任务的失败。<br>PS：并发任务我们一般也只关心，整组任务是否执行完了。</p>
</blockquote>
<p>要达到上面的要求，我们要做一下几点：</p>
<ol>
<li>任务需要单独存储，包括任务的完成以及失败回调，还有任务的状态，是否开始，取消等</li>
<li>单任务与多任务的处理需要分开，在多任务的处理中，大部分都跟单任务一样，就是添加是多个，这里我决定使用继承，后面，我们还可以做一些神奇的操作</li>
<li>关于任务的封装，之前是一个 <code>block</code>，现在是需要存储状态、回调等，而且状态需要修改，最后简单封装成一个 <code>class</code>，多任务 <code>class</code> 需要一个属性，子任务列表。</li>
</ol>
<blockquote>
<p>关于任务的封装，还有一种选择是封装成 <code>struct</code>，但是 <code>swift</code> 中 <code>struct</code> 是值类型，值类型有一个特性 <code>Copy-on-Write</code>，而任务的创建以及属性赋值，不是一次性，例如回调、状态，都是需要修改属性，很容易触发 <code>Copy-on-Write</code>，修改就会放到一个 <code>Copy</code> 的对象里面，全部修改都白费。所以改用 <code>class</code>。</p>
</blockquote>
<h2 id="任务封装"><a href="#任务封装" class="headerlink" title="任务封装"></a>任务封装</h2><p>我们列举一下，任务的属性，以及需要实现的方法：<br>任务 <code>Task</code>：</p>
<ul>
<li>状态</li>
<li>完成回调</li>
<li>错误回调</li>
<li>结束回调（任务结束，不论成功与失败）</li>
<li>任务开始</li>
<li>任务取消</li>
<li>任务完成（任务 <code>block</code> 中，任务结束）</li>
<li>任务 <code>block</code></li>
</ul>
<p>多任务 <code>MutiTask</code>：</p>
<ul>
<li>多任务（任务数组）</li>
</ul>
<p>因为单任务 <code>MyGCD</code> 与 多任务 <code>MyGCD2</code> 是继承关系，属性 <code>task</code> ，在不同的类里面，<code>task</code>代表不同的任务，而且单任务 <code>Task</code>、多任务 <code>MutiTask</code> 之间有好多共同的地方，这时抽象一个 <code>OneTask</code> 协议，属性 <code>task</code> 标记类型为 <code>OneTask</code>，具体的类型，由类自己实现。</p>
<blockquote>
<p>单任务 <code>MyGCD</code> 与 多任务 <code>MyGCD2</code> 的名字有点不合适，改个名字吧，单任务 <code>AsyncTask</code> 、 多任务 <code>AsyncMutiTask</code>。</p>
</blockquote>
<p>协议 <code>OneTask</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protocol OneTask &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务状态</span><br><span class="line">    var state: MyGCD.State &#123;get set&#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    var complete: MyGCD.ResultAction? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    var error: MyGCD.ResultAction? &#123; get set &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束回调</span><br><span class="line">    var endAction: MyGCD.EndAction? &#123; get set &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 开始</span><br><span class="line">    func start()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter state: 结束的状态</span><br><span class="line">    func end(_ state:MyGCD.State)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取消</span><br><span class="line">    func cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务 <code>Task</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 任务</span><br><span class="line">class Task:OneTask &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务Block</span><br><span class="line">    var task: TaskAction</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务状态</span><br><span class="line">    var state: State &#x3D; .idle</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    var complete: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    var error: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束回调</span><br><span class="line">    var endAction: EndAction?</span><br><span class="line"></span><br><span class="line">    init(_ task: @escaping TaskAction) &#123;</span><br><span class="line">        self.task &#x3D; task</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func start() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func end(_ state: State) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func cancel() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务 <code>MutiTask</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MutiTask:OneTask &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;任务List</span><br><span class="line">    var tasks: [Task] &#x3D; [Task]()</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 状态</span><br><span class="line">    var state: State &#x3D; .idle</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    var complete: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    var error: ResultAction?</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束回调</span><br><span class="line">    var endAction: AsyncTask.EndAction?</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; 结束的任务个数</span><br><span class="line">    var endCount &#x3D; 0</span><br><span class="line"></span><br><span class="line">    init(_ tasks: [Task] &#x3D; [], complete: ResultAction? &#x3D; nil, error: ResultAction? &#x3D; nil) &#123;</span><br><span class="line">        self.tasks.append(contentsOf: tasks)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func add(_ task: Task) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func start() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func end(_ state: State) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func cancel() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>任务的状态：<code>完成</code> 、<code>错误</code> 、<code>取消</code>，多任务时，状态有点不够用，未添加时，应该是<code>空闲</code>状态，开始执行任务时，应该是<code>执行中</code>，完成时，是所有任务都完成，<code>完成所有</code>，下面是扩展后的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 任务状态</span><br><span class="line">enum State &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 空闲</span><br><span class="line">    case idle</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 任务中</span><br><span class="line">    case doing</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 完成</span><br><span class="line">    case complete(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 错误</span><br><span class="line">    case error(Result)</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 取消</span><br><span class="line">    case cancel</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 多任务</span><br><span class="line">    case completeAll([Result])</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">## 结果</span><br><span class="line"></span><br><span class="line">结果在多任务的时候也要添加一个多任务的结果：</span><br></pre></td></tr></table></figure>
<p>/// 结果<br>struct Result {<br>    /// 状态码<br>    var code: Int<br>    /// 信息<br>    var message: String<br>    /// 数据<br>    var data: Any?<br>    /// 多任务结果<br>    var results: [Result]</p>
<pre><code>init(_ code: Int,_ message: String = &quot;&quot;,_ data: Any? = nil,_ results: [Result] = []) {
    self.code = code
    self.message = message
    self.data = data
    self.results = results
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">扩展 &#96;extension&#96;</span><br></pre></td></tr></table></figure>
<p>extension AsyncTask.Result {<br>    static func results(_ code: Int,_ message: String?,_ data: Any? = nil,_ results: [AsyncTask.Result] = []) -&gt; AsyncTask.Result {<br>        return AsyncTask.Result(code,message ?? “”,data,results)<br>    }</p>
<pre><code>static func results(_ results: [AsyncTask.Result],_ code: Int = 200,_ message: String? = nil) -&gt; AsyncTask.Result {
    return AsyncTask.Result(code,message ?? &quot;&quot;,nil,results)
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Task 实现</span><br><span class="line"></span><br><span class="line">现在来实现&#96;Task&#96;，填充所有逻辑：</span><br></pre></td></tr></table></figure>
<p>func start() {</p>
<pre><code>lock()
guard case .idle = state else {
    unlock()
    return
}

state = .doing
unlock()

AsyncTask.startTask { [weak self] in
    guard let self = self else {
        return
    }

    self.task(self)
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;lock()&#96; 、&#96;unlock()&#96; 线程锁，因为任务是异步执行，状态的判断很容易有多线程问题，数据不一致，每次判断都得加锁，保证数据的线程安全。</span><br><span class="line">&#96;AsyncTask.startTask&#96; 是一个类方法，所有的任务都是异步执行，所以声明了一个类属性的 &#96;queue&#96; ，一个并发队列。</span><br></pre></td></tr></table></figure>
<p>/// 队列<br>fileprivate static var queue: DispatchQueue = DispatchQueue(label: “AsyncTask”, qos: .default, attributes: .concurrent)<br>/// 开始任务<br>/// - Parameter action: 任务 block<br>fileprivate static func startTask(_ action:@escaping Action) {<br>    self.queue.async(execute: action)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来实现完成方法，任务执行后，需要手动调用的。</span><br></pre></td></tr></table></figure>
<p>func end(_ state:State) {</p>
<pre><code>lock()
self.state = state
unlock()

switch state {
    case .complete(let result):
        if let complete = complete {
            complete(result)
        }
    case .error(let result):
        if let error = error  {
            error(result)
        }
    default:
        break
}

if let endAction = endAction {
    endAction(state)
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实现取消方法。</span><br></pre></td></tr></table></figure>
<p>func cancel() {</p>
<pre><code>lock()
guard case .idle = state else {
    unlock()
    return
}

state = .cancel
unlock()

if let endAction = endAction {
    endAction(state)
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## MutiTask 实现</span><br><span class="line"></span><br><span class="line">多任务的核心就是添加子任务，绑定一些回调，通过回调来掌控子任务的状态。</span><br></pre></td></tr></table></figure>
<p>func add(_ task:Task) {<br>    lock()<br>    guard case .idle = state else {<br>        print(“MutiTask is doing, can’t add new task!”)<br>        unlock()<br>        return<br>    }<br>    unlock()</p>
<pre><code>self.tasks.append(task)

task.complete = { [weak self] (result) in
    guard let self = self else {
        return
    }

    if let complete = self.complete {
        complete(result)
    }
}

task.error = { [weak self] (result) in
    guard let self = self else {
        return
    }

    if let error = self.error {
        error(result)
    }
}

task.endAction = { [weak self] (state) in
    guard let self = self else {
        return
    }

    self.lock()
    self.endCount += 1
    self.unlock()

    self.end(state)
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 添加方法，开始的判断，是假设，有任务开始后，禁止添加，减少复杂情况的出现，保证我们的任务是简单的多任务并发。</span><br><span class="line">&gt; 在&#96;完成&#96; &#96;错误&#96; 的回调里面，调用 &#96;MutiTask&#96; 相应的回调，相当于 &#96;MutiTask&#96; 中的回调是通用回调。</span><br><span class="line">&gt; &#96;endAction&#96;回调中，记录已完成的子任务数量，并调用&#96;end(state)&#96;方法。</span><br><span class="line"></span><br><span class="line">下面开始实现开始方法：</span><br></pre></td></tr></table></figure>
<p>func start() {<br>    lock()<br>    if case .idle = state {<br>        state = .doing<br>    }<br>    unlock()</p>
<pre><code>for task in tasks {
    task.start()
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结束方法，这里主要是子方法完成后，会回调到这里。</span><br></pre></td></tr></table></figure>
<p>func end(_ state: State) {<br>    lock()<br>    guard case .doing = self.state else {<br>        unlock()<br>        return<br>    }</p>
<pre><code>let count = endCount
unlock()

if count == tasks.count {

    var list = [Result]()
    for task in tasks {

        switch task.state {
            case .complete(let result):
                list.append(result)
            case .error(let result):
                list.append(result)
            default:
                break
        }

    }
    self.state = .completeAll(list)

    if let complete = self.complete {
        complete(.results(list))
    }

    if let endAction = endAction {
        endAction(self.state)
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 根据已完成的子任务数，当所有的任务都完成后，再统调用一个 &#96;complete&#96; 回调，传递所有子任务的状态。</span><br><span class="line">&gt; PS：如有需要可以单独顶一个 &#96;completeAll&#96; 回调，来处理所有任务执行的结果。</span><br><span class="line"></span><br><span class="line">实现取消方法：</span><br></pre></td></tr></table></figure>
<p>func cancel() {<br>    lock()<br>    self.state = .cancel<br>    unlock()</p>
<pre><code>for task in tasks {
    task.cancel()
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## AsyncTask 实现</span><br><span class="line"></span><br><span class="line">任务处理完了，下面就需要实现我们的 &#96;AsyncTask&#96;，由于任务的处理都抽离出来了，本身的处理就少了很多：</span><br></pre></td></tr></table></figure>
<p>class AsyncTask {</p>
<pre><code>///记录总创建的个数
fileprivate static var count:Int = 0
/// 标记，区分每个不同的对象
fileprivate var tag: Int

/// 下一个 Task
fileprivate var nextTask: AsyncTask?
/// 任务
fileprivate var task: OneTask?

/// 错误处理已经添加的回调
fileprivate var errorDidAdded: ErrorCallback?

/// 队列
fileprivate static var queue: DispatchQueue = DispatchQueue(label: &quot;AsyncTask&quot;, qos: .default, attributes: .concurrent)

init() {

    tag = AsyncTask.count

    print(&quot;init : \(tag)&quot;)

    AsyncTask.count += 1
}

deinit {
    print(&quot;deinit : \(tag)&quot;)
}

// MARK: 任务处理

/// 任务
/// - Parameter task: block 任务
/// - Returns: AsyncTask
@discardableResult
func task(_ task:@escaping TaskAction) -&gt; AsyncTask {

    addTask(task)
    start()

    return self
}

/// 开始任务
/// - Returns: AsyncTask
@discardableResult
func start() -&gt; AsyncTask {
    task?.start()
    return self
}

/// 下一个任务
/// - Parameter action: block 任务
/// - Returns: MyGCD
@discardableResult
func next(_ task:@escaping TaskAction) -&gt; AsyncTask {

    nextTask = createTask(task)

    return nextTask!
}

/// 完成处理
/// - Parameter action: block 处理
/// - Returns: MyGCD
@discardableResult
func complete(_ action:@escaping ResultAction) -&gt; AsyncTask {
    task?.complete = action
    return self
}

/// 错误处理
/// - Parameter action: block 处理
/// - Returns: MyGCD
@discardableResult
func error(_ action:@escaping ResultAction) -&gt; AsyncTask {
    task?.error = action
    transmitError(action)

    return self
}

/// 任务结束
fileprivate func end(_ state: State) {
    switch state {
        case .complete(_):
            fallthrough
        case .completeAll(_):
            if let nextTask = nextTask {
                nextTask.start()
        }
        case .error(_):
            nextTask?.task?.cancel()
        case .cancel:
            nextTask?.task?.cancel()
        default:
            break
    }

    nextTask = nil
}

// MARK: 私有函数
fileprivate func addTask(_ task:@escaping TaskAction) {
    self.task = Task(task)

    var gcd:AsyncTask? = self
    self.task?.endAction = { state in
        gcd?.end(state)

        gcd = nil
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每个方法的实现，都比较简单，就不一一描述了。</span><br><span class="line"></span><br><span class="line">## AsyncMutiTask 实现</span><br><span class="line"></span><br><span class="line">&#96;AsyncMutiTask&#96; 与 &#96;AsyncTask&#96; 的区别就是，添加多任务，执行多任务，直接上代码：</span><br></pre></td></tr></table></figure>
<p>class AsyncMutiTask: AsyncTask {</p>
<pre><code>override init() {
    super.init()

    self.task = MutiTask()
    var gcd:AsyncTask? = self
    self.task?.endAction = { state in
        gcd?.end(state)

        gcd = nil
    }
}

/// 任务
/// - Parameter tasks: block 数组
/// - Returns: AsyncTask
@discardableResult
func tasks(_ tasks:[TaskAction]) -&gt; AsyncTask {
    addTasks(tasks)
    start()
    return self
}

/// 开始任务
/// - Returns: AsyncTask
@discardableResult
override func start() -&gt; AsyncTask {
    self.task?.start()
    return self
}

// MARK: 私有函数
fileprivate func addTasks(_ tasks:[TaskAction]) {
    guard let mutiTask = self.task as? MutiTask else {
        return
    }

    for task in tasks {
        mutiTask.add(Task(task))
    }
}

override fileprivate func addTask(_ task: @escaping TaskAction) {
    guard let mutiTask = self.task as? MutiTask else {
        return
    }
    mutiTask.add(Task(task))
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其他大部分逻辑都抽离到 &#96;MutiTask&#96;中了，实际代码很少。</span><br><span class="line"></span><br><span class="line">下面添加一个一些辅助函数，还有快捷函数，方便快捷调用：</span><br></pre></td></tr></table></figure>
<p>// MARK: 私有辅助函数<br>extension AsyncTask {</p>
<pre><code>/// 创建Task
fileprivate func createTask(_ task: @escaping TaskAction) -&gt; AsyncTask {

    let newTask = AsyncTask()
    newTask.errorDidAdded = {[weak self] action in
        if self?.task?.error == nil {
            self?.error(action)
        }else{
            self?.transmitError(action)
        }
    }

    newTask.addTask(task)

    return newTask
}

/// 创建MutiTask
fileprivate func createMutiTask(_ tasks:[TaskAction]) -&gt; AsyncTask {

    let newTask = AsyncMutiTask()
    newTask.errorDidAdded = {[weak self] action in
        if self?.task?.error == nil {
            self?.error(action)
        }else{
            self?.transmitError(action)
        }
    }

    newTask.addTasks(tasks)

    return newTask
}

/// 传递Error处理
fileprivate func transmitError(_ action:@escaping ResultAction) {

    if let errorDidAdded = errorDidAdded {
        errorDidAdded(action)
    }
}

/// 开始任务
/// - Parameter action: 任务 block
fileprivate static func startTask(_ action:@escaping Action) {
    self.queue.async(execute: action)
}</code></pre><p>}</p>
<p>// MARK: 快捷方法<br>extension AsyncTask {</p>
<pre><code>/// 下一组任务
/// - Parameter tasks: 任务数组
/// - Returns: AsyncTask
func nexts(_ tasks:[TaskAction]) -&gt; AsyncTask {

    nextTask = createMutiTask(tasks)

    return nextTask!
}

/// 任务
/// - Parameter task: block 任务
/// - Returns: AsyncTask
@discardableResult
static func task(_ task:@escaping TaskAction) -&gt; AsyncTask {
    return AsyncTask().task(task)
}

/// 任务
/// - Parameter tasks: block 数组
/// - Returns: AsyncTask
@discardableResult
static func tasks(_ tasks:[TaskAction]) -&gt; AsyncTask {
    return AsyncMutiTask().tasks(tasks)
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 测试</span><br><span class="line"></span><br><span class="line">测试代码：</span><br></pre></td></tr></table></figure>
<p>AsyncTask.task { task in<br>    createTask(“任务1”) {<br>        task.end(.sucess())<br>    }<br>}.complete{ (result) in<br>    print(“任务1 complete: (result)”)<br>}.nexts([<br>    { task in<br>        createTask(“任务2_1”) {<br>            task.end(.complete(.result(200, “任务2_1 完成”)))<br>        }<br>    },{ task in<br>        createTask(“任务2_2”) {<br>            task.end(.error(404,”任务2_2 完成”))<br>        }<br>    },{ task in<br>        createTask(“任务2_3”) {<br>            task.end(.complete(.result(200, “任务2_3 完成”)))<br>        }<br>    },{ task in<br>        createTask(“任务2_4”) {<br>            task.end(.error(404,”任务2_4 错误”))<br>        }<br>    },]).complete{ (result) in<br>        print(“任务 complete: (result)”)<br>}.error{ (result) in<br>    print(“任务有2 错误: (result)”)<br>}.next { task in<br>    createTask(“任务3”) {<br>        task.end(.sucess())<br>    }<br>}.complete{ (result) in<br>    print(“任务3 complete: (result)”)<br>}.error{ (result) in<br>    print(“任务有 错误: (result)”)<br>}<br>print(“发布任务完毕”)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure>
<p>init : 0<br>init : 1<br>任务1 发布<br>任务1 开始<br>init : 2<br>发布任务完毕<br>任务1 结束<br>任务1 complete: Result(code: 200, message: “”, data: nil, results: [])<br>deinit : 0<br>任务2_1 发布<br>任务2_2 发布<br>任务2_3 发布<br>任务2_2 开始<br>任务2_3 开始<br>任务2_1 开始<br>任务2_4 发布<br>任务2_4 开始<br>任务2_2 结束<br>任务2_4 结束<br>任务2_1 结束<br>任务有2 错误: Result(code: 404, message: “任务2_2 完成”, data: nil, results: [])<br>任务2_3 结束<br>任务有2 错误: Result(code: 404, message: “任务2_4 错误”, data: nil, results: [])<br>任务 complete: Result(code: 200, message: “任务2_1 完成”, data: nil, results: [])<br>任务 complete: Result(code: 200, message: “任务2_3 完成”, data: nil, results: [])<br>任务 complete: Result(code: 200, message: “”, data: nil, results: [MLibDemo.AsyncTask.Result(code: 200, message: “任务2_1 完成”, data: nil, results: []), MLibDemo.AsyncTask.Result(code: 404, message: “任务2_2 完成”, data: nil, results: []), MLibDemo.AsyncTask.Result(code: 200, message: “任务2_3 完成”, data: nil, results: []), MLibDemo.AsyncTask.Result(code: 404, message: “任务2_4 错误”, data: nil, results: [])])<br>deinit : 1<br>任务3 发布<br>任务3 开始<br>任务3 结束<br>任务3 complete: Result(code: 200, message: “”, data: nil, results: [])<br>deinit : 2</p>
<p>```</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>前面还能说一下思路，到 <code>3.0</code> 已经变成直接上代码，中间试验的时候碰到的问题，基本都写下了，整个解决回调地狱，解决的关键其实是在前面，后面更多是试验，然后封装。</p>
<blockquote>
<p>PS：希望对大家有帮助，文笔太差，让大家见笑了。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/zhrmghgfff/MTips.git" target="_blank" rel="noopener">代码</a>我已上传GitHub，会略有修改，仅供参考</p>

    </div>
    </article>
</div>

    <div class="_toc">
        <strong class="toc-title">
        Contents
        </strong>
        <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#回调地狱"><span class="toc-text">回调地狱</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#回调地狱的思考"><span class="toc-text">回调地狱的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#链式编程"><span class="toc-text">链式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改的思路"><span class="toc-text">修改的思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyGCD-1-0"><span class="toc-text">MyGCD 1.0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#链式调用"><span class="toc-text">链式调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#还是信号量"><span class="toc-text">还是信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回归现实"><span class="toc-text">回归现实</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-0-大功告成"><span class="toc-text">1.0 大功告成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyGCD-2-0"><span class="toc-text">MyGCD 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#增加next"><span class="toc-text">增加next</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#增加-State"><span class="toc-text">增加 State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#增加-error"><span class="toc-text">增加 error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#增加complete"><span class="toc-text">增加complete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改endAction"><span class="toc-text">修改endAction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试"><span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#统一错误处理"><span class="toc-text">统一错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-0-完成"><span class="toc-text">2.0 完成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyGCD-3-0"><span class="toc-text">MyGCD 3.0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思考"><span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#任务封装"><span class="toc-text">任务封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态"><span class="toc-text">状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#后记"><span class="toc-text">后记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#代码"><span class="toc-text">代码</span></a></li></ol></li></ol>
        </div>
    </div>

</section>


    <nav class="post-nav">
        
            <div class="page-tags">
                
            </div>
        
    </nav>



    <nav class="paginator clearfix">
        
        
            <a class="next" href="/2020/05/28/iOS-Runtime%E6%8E%A2%E7%A9%B6/">
                
                <span class="prev-text">iOS Runtime探究</span>
                <i class="iconfont icon-right"></i>
            </a>
        
    </nav>


            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> | Theme <a href="https://github.com/zjx137/hexo-theme-Tsu" target="_blank" rel="noopener">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
